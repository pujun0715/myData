/*
Navicat MySQL Data Transfer

Source Server         : 云服务器
Source Server Version : 80027
Source Host           : 123.56.220.192:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 80027
File Encoding         : 65001

Date: 2022-08-24 11:33:09
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for ms_admin
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin`;
CREATE TABLE `ms_admin` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_admin
-- ----------------------------
INSERT INTO `ms_admin` VALUES ('1', 'admin', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');
INSERT INTO `ms_admin` VALUES ('2', 'mszlu', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');

-- ----------------------------
-- Table structure for ms_admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin_permission`;
CREATE TABLE `ms_admin_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `admin_id` bigint NOT NULL,
  `permission_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_admin_permission
-- ----------------------------
INSERT INTO `ms_admin_permission` VALUES ('1', '1', '1');
INSERT INTO `ms_admin_permission` VALUES ('2', '2', '1');

-- ----------------------------
-- Table structure for ms_article
-- ----------------------------
DROP TABLE IF EXISTS `ms_article`;
CREATE TABLE `ms_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `comment_counts` int DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `view_counts` int DEFAULT NULL COMMENT '浏览数量',
  `weight` int NOT NULL COMMENT '是否置顶',
  `author_id` bigint DEFAULT NULL COMMENT '作者id',
  `body_id` bigint DEFAULT NULL COMMENT '内容id',
  `category_id` int DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1560081784687362051 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_article
-- ----------------------------
INSERT INTO `ms_article` VALUES ('1', '32', '1621947720727', '\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。', 'springboot介绍以及入门案例', '207', '1', '1', '1555756550424039427', '2');
INSERT INTO `ms_article` VALUES ('9', '0', '1613947720727', 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。', 'Vue.js 到底是什么', '11', '0', '1', '20', '2');
INSERT INTO `ms_article` VALUES ('10', '2', '1523947720727', '本节将介绍如何在项目中使用 Element。', 'Element相关', '19', '0', '1', '21', '2');
INSERT INTO `ms_article` VALUES ('1405564731300831233', '0', '1623947720727', '计算机网络实验', '计算机网络', '36', '0', '1', '1558821583481012226', '6');
INSERT INTO `ms_article` VALUES ('1405909844724051969', '3', '1624030002164', 'spring 介绍', 'spring介绍', '34', '0', '1', '1555780351882854402', '2');
INSERT INTO `ms_article` VALUES ('1405916999732707330', '0', '1624031708047', 'springboot入门案例', 'SpringBoot入门案例', '36', '0', '1', '1405916999854342146', '2');
INSERT INTO `ms_article` VALUES ('1554430960475545601', '6', '1659440195573', '测试上传文件功能', '我的第一篇博客', '28', '0', '1', '1554430960521682945', '3');
INSERT INTO `ms_article` VALUES ('1555750866936598530', '3', '1659754885764', 'Css学习笔记', 'Css学习总结', '22', '0', '1555096810769481729', '1555755544994844674', '1');
INSERT INTO `ms_article` VALUES ('1558042675785564161', '1', '1660301295596', 'java 后端春招秋招秘诀\n', 'Java后端基础', '8', '0', '1555096810769481729', '1558397539745071106', '2');
INSERT INTO `ms_article` VALUES ('1558075068965781505', '1', '1660309018730', 'spring核心原理，面试常考', 'spring核心原理', '2', '0', '1555096810769481729', '1558075069192273922', '2');
INSERT INTO `ms_article` VALUES ('1558406356893499394', '2', '1660388003930', 'Mybatis的一二级缓存详解', 'Mabatis缓存机制', '4', '0', '1558082417612881922', '1558406356943831042', '2');
INSERT INTO `ms_article` VALUES ('1560081784687362050', '1', '1660787457045', 'springMVC流程控制', 'SpringMVC原理流程', '3', '0', '1558082417612881922', '1560081978141245442', '2');

-- ----------------------------
-- Table structure for ms_article_body
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_body`;
CREATE TABLE `ms_article_body` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `article_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1560081978141245443 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_article_body
-- ----------------------------
INSERT INTO `ms_article_body` VALUES ('1', '# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n', '<h2>2018-01-04</h2>\n<pre><code class=\"lang-\"># 使用vue的Webpack模板生成脚手架\n</code></pre>\n<h2>2018-01-05</h2>\n<pre><code class=\"lang-\"># 引入ElementUI\n\n# babel-plugin-component自定义主题\n# 首页\n# 登陆页\n# 注册页面\n# 日志页\n</code></pre>\n<h2>2018-01-07</h2>\n<pre><code class=\"lang-\"># 调整底部栏始终固定在底部\n# 日志页 添加时间轴\n# 首页的文章列表\n</code></pre>\n<h2>2018-01-08</h2>\n<pre><code class=\"lang-\"># 使用组件-博客作者tab页 \n# 添加第三方图标\n</code></pre>\n<h2>2018-01-09</h2>\n<pre><code class=\"lang-\"># 调整顶部导航栏：激活文字颜色，click点击\n# 组件-最新文章tab页\n\n# 最新文章、最热文章使用相同组件\n# 底部栏设计\n# 页面与两边边距改为100\n</code></pre>\n<h2>2018-01-10</h2>\n<pre><code class=\"lang-\"># 写博客 引入mavonEditor编辑器\n# 顶部导航栏都放入一个Menu中\n# 写文章页面\n#　mavonEditor局部引入\n\n#　页面的中间区域固定宽度，自动居中\n# 发布和取消\n# 发布dialog\n\n</code></pre>\n<h2>2018-01-11</h2>\n<pre><code class=\"lang-\"># 文章组件用守卫来改变body背景色\n# 调整登陆和注册页面，使其居中\n\n#子页面调整根元素为div\n#文章详情页\n\n</code></pre>\n<h2>2018-01-12</h2>\n<pre><code class=\"lang-\"># 文章详情页  内容  评论等\n\n</code></pre>\n<h2>2018-01-13</h2>\n<pre><code class=\"lang-\">## 重新调整页面结构	\n#顶部和底部 抽成  BaseHeader BaseFooter 组件\n#BlogView为单独页，以前是Home的子路由\n\n</code></pre>\n<h2>2018-01-15</h2>\n<pre><code class=\"lang-\"># 文章分类去掉子级\n# 将首页的文章列表抽成 ArticleItem组件\n# 增加文章的评论展示\n# 增加文章分类、标签页\n\n</code></pre>\n<h2>2018-01-15  2</h2>\n<pre><code class=\"lang-\"># 回到顶部去掉过渡动画（影响顶部导航栏）\n# 顶部导航栏 增加登录后菜单\n# 首页增加 最热标签\n# 增加 文章分类 标签的详情页\n# 将文章详情页、 文章分类标签页 改为Home的子路由（以前单独页）\n# Home组件增加路由判断：更正导航栏的状态、条件显示底部栏\n\n</code></pre>\n<h2>2018-01-16</h2>\n<pre><code class=\"lang-\"># 将写文章的顶部Header合并到BaseHeader中\n# 图片都放到了static目录下\n\n</code></pre>\n<h2>2018-01-24</h2>\n<pre><code class=\"lang-\"># 将自定义的theme放到assets下\n# 加入axios\n# 加入vuex\n# 实现登录\n# 实现退出\n\n</code></pre>\n<h2>2018-01-25</h2>\n<pre><code class=\"lang-\"># 实现注册逻辑\n# 写文章功能实现\n# 写文章时支持插入图片\n\n</code></pre>\n<h2>2018-01-26</h2>\n<pre><code class=\"lang-\"># 引入lodash工具类\n# 优化写文章的工具栏：滚动时固定顶部\n# 写文章 后台获取文章分类和标签\n\n# 首页的文章列表\n\n</code></pre>\n<h2>2018-01-27</h2>\n<pre><code class=\"lang-\"># 修改首页文章列表的样式\n# 首页加载文章功能\n# 文章查看功能\n# 文章分类和标签功能列表\n\n</code></pre>\n<h2>2018-01-28</h2>\n<pre><code class=\"lang-\"># 文章分类和标签详情\n\n</code></pre>\n<h2>2018-01-29</h2>\n<pre><code class=\"lang-\"># 文章分类和标签的文章数\n# 首页最热文章\n# 首页最新文章\n# 首页最热标签\n\n</code></pre>\n<h2>2018-01-30</h2>\n<pre><code class=\"lang-\"># BaseHeader放回views中\n# 修改Axios后置拦截，全局处理错误\n# 将登录 退出 和头像 放到一起\n\n</code></pre>\n', '1');
INSERT INTO `ms_article_body` VALUES ('20', 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。\n\n# 起步\n\n> 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。\n\n尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n```\n安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。\n\n# 声明式渲染\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n```javascript\n<div id=\"app\">\n  {{ message }}\n</div>\n\n```\n```javascript\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n\n```\n我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n\n除了文本插值，我们还可以像这样来绑定元素特性：\n\n\n\n\n\n\n', '<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br />\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>\n<h1>起步</h1>\n<blockquote>\n<p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>\n</blockquote>\n<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n</code></div></pre>\n<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p>\n<h1>声明式渲染</h1>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;div id=<span class=\"hljs-string\">\"app\"</span>&gt;\n  {{ message }}\n&lt;<span class=\"hljs-regexp\">/div&gt;\n\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n  }\n})\n\n</code></div></pre>\n<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性：</p>\n', '9');
INSERT INTO `ms_article_body` VALUES ('21', '## 快速上手\n\n本节将介绍如何在项目中使用 Element。\n\n### 使用 Starter Kit\n我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。\n\n如果不希望使用我们提供的模板，请继续阅读。\n\n### 使用 vue-cli\n\n我们还可以使用 vue-cli 初始化项目，命令如下：\n\n```language\n> npm i -g vue-cli\n> mkdir my-project && cd my-project\n> vue init webpack\n> npm i && npm i element-ui\n```\n\n### 引入 Element\n你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。\n\n#### 完整引入\n在 main.js 中写入以下内容：\n```javascript\nimport Vue from \'vue\'\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nimport App from \'./App.vue\'\n\nVue.use(ElementUI)\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n})\n\n```\n以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。\n\n#### 按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n\n首先，安装 babel-plugin-component：\n\n', '<h2>快速上手</h2>\n<p>本节将介绍如何在项目中使用 Element。</p>\n<h3>使用 Starter Kit</h3>\n<p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p>\n<p>如果不希望使用我们提供的模板，请继续阅读。</p>\n<h3>使用 vue-cli</h3>\n<p>我们还可以使用 vue-cli 初始化项目，命令如下：</p>\n<pre><code class=\"lang-language\">&gt; npm i -g vue-cli\n&gt; mkdir my-project &amp;&amp; cd my-project\n&gt; vue init webpack\n&gt; npm i &amp;&amp; npm i element-ui\n</code></pre>\n<h3>引入 Element</h3>\n<p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p>\n<h4>完整引入</h4>\n<p>在 main.js 中写入以下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> ElementUI <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'element-ui\'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\'element-ui/lib/theme-chalk/index.css\'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./App.vue\'</span>\n\nVue.use(ElementUI)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =&gt;</span> h(App)\n})\n\n</code></div></pre>\n<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>\n<h4>按需引入</h4>\n<p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>\n<p>首先，安装 babel-plugin-component：</p>\n', '10');
INSERT INTO `ms_article_body` VALUES ('1405564731351162882', '666666666666', '<p>666666666666</p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1405909844828909569', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image-20210523173712142](img/image-20210523173712142.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n![image-20210523174032053](img/image-20210523174032053.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image-20210523181737720](img/image-20210523181737720.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image-20210523182426404](img/image-20210523182426404.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405909844724051969');
INSERT INTO `ms_article_body` VALUES ('1405916999854342146', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405916999732707330');
INSERT INTO `ms_article_body` VALUES ('1554069326129201154', '66666666666666666', '<p>66666666666666666</p>\n', '1554069326032732161');
INSERT INTO `ms_article_body` VALUES ('1554430960521682945', 'test：上传图片到七牛云\n![QQ图片20200103225921.png](http://rfzh8op8d.hn-bkt.clouddn.com/25e54f38-1a21-46a1-8559-1a55a47ec3ee.png)', '<p>test：上传图片到七牛云<br />\n<img src=\"http://rfzh8op8d.hn-bkt.clouddn.com/25e54f38-1a21-46a1-8559-1a55a47ec3ee.png\" alt=\"QQ图片20200103225921.png\" /></p>\n', '1554430960475545601');
INSERT INTO `ms_article_body` VALUES ('1555408506876739586', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image-20210523173241557](img/image-20210523173241557.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image-20210523173712142](img/image-20210523173712142.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n![image-20210523174032053](img/image-20210523174032053.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步：**添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：**在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：**添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image-20210523181737720](img/image-20210523181737720.png)\n\n**第二步：**打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image-20210523182426404](img/image-20210523182426404.png)\n\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"img/image-20210523173241557.png\" alt=\"image-20210523173241557\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p>**第一步：**创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步：**添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>**第二步：**在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p>**第一步：**添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步：**打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p>**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1');
INSERT INTO `ms_article_body` VALUES ('1555414237650767873', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image-20210523173241557](img/image-20210523173241557.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image-20210523173712142](img/image-20210523173712142.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n![image-20210523174032053](img/image-20210523174032053.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步：**添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：**在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：**添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image-20210523181737720](img/image-20210523181737720.png)\n\n**第二步：**打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image-20210523182426404](img/image-20210523182426404.png)\n\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"img/image-20210523173241557.png\" alt=\"image-20210523173241557\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p>**第一步：**创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步：**添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>**第二步：**在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p>**第一步：**添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步：**打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p>**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1');
INSERT INTO `ms_article_body` VALUES ('1555417450693144577', '# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"img/image-20210523173241557.png\" alt=\"image-20210523173241557\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p>**第一步：**创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步：**添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>**第二步：**在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p>**第一步：**添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步：**打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p>**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1');
INSERT INTO `ms_article_body` VALUES ('1555745063106142210', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ping www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">tracert www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">arp -a //查看缓存\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n</code></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\"> netstat -an //**查看计算机当前的网络连接状况**\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><code class=\"lang-cpp\">pc0上  ping 192.168.1.3(PC1)的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">PC1上ping 192.168.1.2（PC0）的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">在PC0和PC1上ping网关地址192.168.1.1\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1555748794325426178', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ping www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">tracert www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">arp -a //查看缓存\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n</code></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\"> netstat -an //**查看计算机当前的网络连接状况**\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><code class=\"lang-cpp\">pc0上  ping 192.168.1.3(PC1)的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">PC1上ping 192.168.1.2（PC0）的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">在PC0和PC1上ping网关地址192.168.1.1\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1555749216809279490', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ping www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">tracert www.baidu.com\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">arp -a //查看缓存\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n</code></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><code class=\"lang-cpp\"> netstat -an //**查看计算机当前的网络连接状况**\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><code class=\"lang-cpp\">ipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><code class=\"lang-cpp\">pc0上  ping 192.168.1.3(PC1)的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">PC1上ping 192.168.1.2（PC0）的ip地址\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><code class=\"lang-cpp\">在PC0和PC1上ping网关地址192.168.1.1\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1555750867343446018', '   Css学习总结\n\n​     &ensp;&ensp;通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。\n\n其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。\n\n &ensp;&ensp; 总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获\n\n## 代码：\n\n~~~css\nbody{\n    background-color: #cccccc;\n    font-family: \"Microsoft Yahei\",\"SimHei\";\n    margin: 0 auto;\n    max-width: 900px;\n    border: solid #FFFFFF;\n}\nheader{\n    background: #F47D31;\n    display: block;\n    color: #FFFFFF;\n    text-align: center;\n}\nheader h2{\n    margin: 0;\n}\nh1{\n    font-size: 72px;\n    margin: 0;\n}\nh2{\n    font-size: 24px;\n    margin: 0;\n    text-align: center;\n    /*color: #F47D31;*/\n}\nh3{\n    font-size: 18px;\n    margin: 0;\n    text-align: center;\n    color: #F47D31;\n}\nh4{\n    color: #F47D31;\n    background-color: #FFFFFF;\n    -webkit-box-shadow:2px 2px 20px #888;\n    -webkit-transform:rotate(-45deg);\n    -moz-box-shadow: 2px 2px 20px #888;\n    -moz-transform:rotate(-45deg);\n    position: absolute;\n    padding: 0 150px;\n    top: 50px;\n    left: -120px;\n    text-align: center;\n}\nnav{\n    display: block;\n    width:25%;\n    float:left;\n}\nnav a:link, nav a:visited{\n    display:block;\n    color: #F47D31;\n    border-bottom: 3px solid #FFFFFF;\n    padding: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    margin: 5px;\n}\nnav a:hover{\n    color: white;\n    background-color: #F47D31;\n}\nnav h3{\n    margin: 15px;\n    color: white;\n}\n#container{\n    background-color: #888888;\n}\nsection{\n    display: block;\n    width: 50%;\n    float:left;\n}\narticle{\n    background: #eee;\n    display: block;\n    margin: 10px;\n    padding: 10px;\n    /*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */\n    border-radius: 10px;\n    /*-webkit-box-shadow:2px 2px 20px #888;*/\n    /*-webkit-transform:rotate(-10deg);*/\n    /*-moz-box-shadow:2px 2px 20px #888;*/\n    /*-moz-transform:rotate(-10deg);*/\n    transform:rotate(-10deg);\n    box-shadow: 2px 2px 20px #888;\n}\narticle header{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle footer{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle h1{\n    font-size: 18px;\n}\naside {\n    display: block;\n    width: 25%;\n    float: left;\n}\naside h3{\n    margin: 15px;\n    color: white;\n}\naside p{\n    margin: 15px;\n    color: white;\n    font-weight: bold;\n    font-style: italic;\n}\nfooter{\n    clear:both;\n    display: block;\n    background: #F47D31;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 15px;\n}\nfooter h2{\n    font-size: 14px;\n    color: white;\n}\n~~~\n\n## 效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210310204141656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzMzc3NDk0,size_16,color_FFFFFF,t_70#pic_center)\n\n', '<p>Css学习总结</p>\n<p>​       通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。</p>\n<p>其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。</p>\n<p>   总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获</p>\n<h2><a id=\"_8\"></a>代码：</h2>\n<pre><code class=\"lang-css\">body{\n    background-color: #cccccc;\n    font-family: &quot;Microsoft Yahei&quot;,&quot;SimHei&quot;;\n    margin: 0 auto;\n    max-width: 900px;\n    border: solid #FFFFFF;\n}\nheader{\n    background: #F47D31;\n    display: block;\n    color: #FFFFFF;\n    text-align: center;\n}\nheader h2{\n    margin: 0;\n}\nh1{\n    font-size: 72px;\n    margin: 0;\n}\nh2{\n    font-size: 24px;\n    margin: 0;\n    text-align: center;\n    /*color: #F47D31;*/\n}\nh3{\n    font-size: 18px;\n    margin: 0;\n    text-align: center;\n    color: #F47D31;\n}\nh4{\n    color: #F47D31;\n    background-color: #FFFFFF;\n    -webkit-box-shadow:2px 2px 20px #888;\n    -webkit-transform:rotate(-45deg);\n    -moz-box-shadow: 2px 2px 20px #888;\n    -moz-transform:rotate(-45deg);\n    position: absolute;\n    padding: 0 150px;\n    top: 50px;\n    left: -120px;\n    text-align: center;\n}\nnav{\n    display: block;\n    width:25%;\n    float:left;\n}\nnav a:link, nav a:visited{\n    display:block;\n    color: #F47D31;\n    border-bottom: 3px solid #FFFFFF;\n    padding: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    margin: 5px;\n}\nnav a:hover{\n    color: white;\n    background-color: #F47D31;\n}\nnav h3{\n    margin: 15px;\n    color: white;\n}\n#container{\n    background-color: #888888;\n}\nsection{\n    display: block;\n    width: 50%;\n    float:left;\n}\narticle{\n    background: #eee;\n    display: block;\n    margin: 10px;\n    padding: 10px;\n    /*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */\n    border-radius: 10px;\n    /*-webkit-box-shadow:2px 2px 20px #888;*/\n    /*-webkit-transform:rotate(-10deg);*/\n    /*-moz-box-shadow:2px 2px 20px #888;*/\n    /*-moz-transform:rotate(-10deg);*/\n    transform:rotate(-10deg);\n    box-shadow: 2px 2px 20px #888;\n}\narticle header{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle footer{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle h1{\n    font-size: 18px;\n}\naside {\n    display: block;\n    width: 25%;\n    float: left;\n}\naside h3{\n    margin: 15px;\n    color: white;\n}\naside p{\n    margin: 15px;\n    color: white;\n    font-weight: bold;\n    font-style: italic;\n}\nfooter{\n    clear:both;\n    display: block;\n    background: #F47D31;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 15px;\n}\nfooter h2{\n    font-size: 14px;\n    color: white;\n}\n</code></pre>\n<h2><a id=\"_143\"></a>效果：</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20210310204141656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUzMzc3NDk0,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n', '1555750866936598530');
INSERT INTO `ms_article_body` VALUES ('1555752701567111169', '   Css学习总结\n\n​     &ensp;&ensp;通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。\n\n其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。\n\n &ensp;&ensp; 总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获\n\n## 代码：\n\n~~~css\nbody{\n    background-color: #cccccc;\n    font-family: \"Microsoft Yahei\",\"SimHei\";\n    margin: 0 auto;\n    max-width: 900px;\n    border: solid #FFFFFF;\n}\nheader{\n    background: #F47D31;\n    display: block;\n    color: #FFFFFF;\n    text-align: center;\n}\nheader h2{\n    margin: 0;\n}\nh1{\n    font-size: 72px;\n    margin: 0;\n}\nh2{\n    font-size: 24px;\n    margin: 0;\n    text-align: center;\n    /*color: #F47D31;*/\n}\nh3{\n    font-size: 18px;\n    margin: 0;\n    text-align: center;\n    color: #F47D31;\n}\nh4{\n    color: #F47D31;\n    background-color: #FFFFFF;\n    -webkit-box-shadow:2px 2px 20px #888;\n    -webkit-transform:rotate(-45deg);\n    -moz-box-shadow: 2px 2px 20px #888;\n    -moz-transform:rotate(-45deg);\n    position: absolute;\n    padding: 0 150px;\n    top: 50px;\n    left: -120px;\n    text-align: center;\n}\nnav{\n    display: block;\n    width:25%;\n    float:left;\n}\nnav a:link, nav a:visited{\n    display:block;\n    color: #F47D31;\n    border-bottom: 3px solid #FFFFFF;\n    padding: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    margin: 5px;\n}\nnav a:hover{\n    color: white;\n    background-color: #F47D31;\n}\nnav h3{\n    margin: 15px;\n    color: white;\n}\n#container{\n    background-color: #888888;\n}\nsection{\n    display: block;\n    width: 50%;\n    float:left;\n}\narticle{\n    background: #eee;\n    display: block;\n    margin: 10px;\n    padding: 10px;\n    /*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */\n    border-radius: 10px;\n    /*-webkit-box-shadow:2px 2px 20px #888;*/\n    /*-webkit-transform:rotate(-10deg);*/\n    /*-moz-box-shadow:2px 2px 20px #888;*/\n    /*-moz-transform:rotate(-10deg);*/\n    transform:rotate(-10deg);\n    box-shadow: 2px 2px 20px #888;\n}\narticle header{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle footer{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle h1{\n    font-size: 18px;\n}\naside {\n    display: block;\n    width: 25%;\n    float: left;\n}\naside h3{\n    margin: 15px;\n    color: white;\n}\naside p{\n    margin: 15px;\n    color: white;\n    font-weight: bold;\n    font-style: italic;\n}\nfooter{\n    clear:both;\n    display: block;\n    background: #F47D31;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 15px;\n}\nfooter h2{\n    font-size: 14px;\n    color: white;\n}\n~~~\n\n## 效果：\n![QQ截图20220806110640.png](http://rfzh8op8d.hn-bkt.clouddn.com/4dc470a7-3699-42e3-a13b-e78c1e9a1c65.png)\n\n', '<p>Css学习总结</p>\n<p>​       通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。</p>\n<p>其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。</p>\n<p>   总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获</p>\n<h2><a id=\"_8\"></a>代码：</h2>\n<pre><code class=\"lang-css\">body{\n    background-color: #cccccc;\n    font-family: &quot;Microsoft Yahei&quot;,&quot;SimHei&quot;;\n    margin: 0 auto;\n    max-width: 900px;\n    border: solid #FFFFFF;\n}\nheader{\n    background: #F47D31;\n    display: block;\n    color: #FFFFFF;\n    text-align: center;\n}\nheader h2{\n    margin: 0;\n}\nh1{\n    font-size: 72px;\n    margin: 0;\n}\nh2{\n    font-size: 24px;\n    margin: 0;\n    text-align: center;\n    /*color: #F47D31;*/\n}\nh3{\n    font-size: 18px;\n    margin: 0;\n    text-align: center;\n    color: #F47D31;\n}\nh4{\n    color: #F47D31;\n    background-color: #FFFFFF;\n    -webkit-box-shadow:2px 2px 20px #888;\n    -webkit-transform:rotate(-45deg);\n    -moz-box-shadow: 2px 2px 20px #888;\n    -moz-transform:rotate(-45deg);\n    position: absolute;\n    padding: 0 150px;\n    top: 50px;\n    left: -120px;\n    text-align: center;\n}\nnav{\n    display: block;\n    width:25%;\n    float:left;\n}\nnav a:link, nav a:visited{\n    display:block;\n    color: #F47D31;\n    border-bottom: 3px solid #FFFFFF;\n    padding: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    margin: 5px;\n}\nnav a:hover{\n    color: white;\n    background-color: #F47D31;\n}\nnav h3{\n    margin: 15px;\n    color: white;\n}\n#container{\n    background-color: #888888;\n}\nsection{\n    display: block;\n    width: 50%;\n    float:left;\n}\narticle{\n    background: #eee;\n    display: block;\n    margin: 10px;\n    padding: 10px;\n    /*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */\n    border-radius: 10px;\n    /*-webkit-box-shadow:2px 2px 20px #888;*/\n    /*-webkit-transform:rotate(-10deg);*/\n    /*-moz-box-shadow:2px 2px 20px #888;*/\n    /*-moz-transform:rotate(-10deg);*/\n    transform:rotate(-10deg);\n    box-shadow: 2px 2px 20px #888;\n}\narticle header{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle footer{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle h1{\n    font-size: 18px;\n}\naside {\n    display: block;\n    width: 25%;\n    float: left;\n}\naside h3{\n    margin: 15px;\n    color: white;\n}\naside p{\n    margin: 15px;\n    color: white;\n    font-weight: bold;\n    font-style: italic;\n}\nfooter{\n    clear:both;\n    display: block;\n    background: #F47D31;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 15px;\n}\nfooter h2{\n    font-size: 14px;\n    color: white;\n}\n</code></pre>\n<h2><a id=\"_143\"></a>效果：</h2>\n<p><img src=\"http://rfzh8op8d.hn-bkt.clouddn.com/4dc470a7-3699-42e3-a13b-e78c1e9a1c65.png\" alt=\"QQ截图20220806110640.png\" /></p>\n', '1555750866936598530');
INSERT INTO `ms_article_body` VALUES ('1555755544994844674', '   Css学习总结\n\n​     &ensp;&ensp;通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。\n\n其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。\n\n &ensp;&ensp; 总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获\n\n## 代码：\n\n~~~css\nbody{\n    background-color: #cccccc;\n    font-family: \"Microsoft Yahei\",\"SimHei\";\n    margin: 0 auto;\n    max-width: 900px;\n    border: solid #FFFFFF;\n}\nheader{\n    background: #F47D31;\n    display: block;\n    color: #FFFFFF;\n    text-align: center;\n}\nheader h2{\n    margin: 0;\n}\nh1{\n    font-size: 72px;\n    margin: 0;\n}\nh2{\n    font-size: 24px;\n    margin: 0;\n    text-align: center;\n    /*color: #F47D31;*/\n}\nh3{\n    font-size: 18px;\n    margin: 0;\n    text-align: center;\n    color: #F47D31;\n}\nh4{\n    color: #F47D31;\n    background-color: #FFFFFF;\n    -webkit-box-shadow:2px 2px 20px #888;\n    -webkit-transform:rotate(-45deg);\n    -moz-box-shadow: 2px 2px 20px #888;\n    -moz-transform:rotate(-45deg);\n    position: absolute;\n    padding: 0 150px;\n    top: 50px;\n    left: -120px;\n    text-align: center;\n}\nnav{\n    display: block;\n    width:25%;\n    float:left;\n}\nnav a:link, nav a:visited{\n    display:block;\n    color: #F47D31;\n    border-bottom: 3px solid #FFFFFF;\n    padding: 10px;\n    text-decoration: none;\n    font-weight: bold;\n    margin: 5px;\n}\nnav a:hover{\n    color: white;\n    background-color: #F47D31;\n}\nnav h3{\n    margin: 15px;\n    color: white;\n}\n#container{\n    background-color: #888888;\n}\nsection{\n    display: block;\n    width: 50%;\n    float:left;\n}\narticle{\n    background: #eee;\n    display: block;\n    margin: 10px;\n    padding: 10px;\n    /*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */\n    border-radius: 10px;\n    /*-webkit-box-shadow:2px 2px 20px #888;*/\n    /*-webkit-transform:rotate(-10deg);*/\n    /*-moz-box-shadow:2px 2px 20px #888;*/\n    /*-moz-transform:rotate(-10deg);*/\n    transform:rotate(-10deg);\n    box-shadow: 2px 2px 20px #888;\n}\narticle header{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle footer{\n    border-radius: 10px;\n    padding: 5px;\n}\narticle h1{\n    font-size: 18px;\n}\naside {\n    display: block;\n    width: 25%;\n    float: left;\n}\naside h3{\n    margin: 15px;\n    color: white;\n}\naside p{\n    margin: 15px;\n    color: white;\n    font-weight: bold;\n    font-style: italic;\n}\nfooter{\n    clear:both;\n    display: block;\n    background: #F47D31;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 15px;\n}\nfooter h2{\n    font-size: 14px;\n    color: white;\n}\n~~~\n\n## 效果：\n![QQ截图20220806110640.png](http://rfzh8op8d.hn-bkt.clouddn.com/4dc470a7-3699-42e3-a13b-e78c1e9a1c65.png)\n\n', '<p>Css学习总结</p>\n<p>​       通过两周对css的学习，了解到其实css就是用来让网页更加美观，它的工作原理就是找到html需要美化的标签然后系统地给标签上色。而如何找到标签，其实css提供一个选择器它的作用就是选择你要美化的标签. 选择器有4种基本类型: 标签选择器(tag),通用选择器(*), 类选择器(.class)和ID选择器(#id).4种选择器可混合使用. 当然,除了基本类型, 也存在着不基本类型,其中包括了: 后台选择器,直接子选择器, 兄弟选择器, 属性选择器。那么如何美化，其实美化就是更改属性对应的值，我们可以把HTML元素标签看作一个object(或者盒子), 每个object(或者盒子)都有内置属性(OO思想), 而CSS更改的就是这些属性的值从而达到美化的效果.而属性又可以细分,其中包括了字体属性,文本属性, 边距属性(就是盒子模型啦), 浮动属性, 列表属性, 背景属性, 定位属性, 表哥属性。最后将更改的值应用到html文件，css提供了三种导入html文件方式，分别为：style属性, style标签 和 link标签导入(级别依次降低.)。</p>\n<p>其实css的工作原理就是找到标签元素然后修改其属性值导入html文件最后应用到界面。</p>\n<p>   总之以上便是这两周内我对css学习总结，我相信在后面的学习过程中我会有进一步的理解与收获</p>\n<h2><a id=\"_8\"></a>代码：</h2>\n<pre><div class=\"hljs\"><code class=\"lang-css\"><span class=\"hljs-selector-tag\">body</span>{\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#cccccc</span>;\n    <span class=\"hljs-attribute\">font-family</span>: <span class=\"hljs-string\">\"Microsoft Yahei\"</span>,<span class=\"hljs-string\">\"SimHei\"</span>;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> auto;\n    <span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">900px</span>;\n    <span class=\"hljs-attribute\">border</span>: solid <span class=\"hljs-number\">#FFFFFF</span>;\n}\n<span class=\"hljs-selector-tag\">header</span>{\n    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#F47D31</span>;\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#FFFFFF</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n}\n<span class=\"hljs-selector-tag\">header</span> <span class=\"hljs-selector-tag\">h2</span>{\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-selector-tag\">h1</span>{\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">72px</span>;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n}\n<span class=\"hljs-selector-tag\">h2</span>{\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n    <span class=\"hljs-comment\">/*color: #F47D31;*/</span>\n}\n<span class=\"hljs-selector-tag\">h3</span>{\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#F47D31</span>;\n}\n<span class=\"hljs-selector-tag\">h4</span>{\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#F47D31</span>;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#FFFFFF</span>;\n    <span class=\"hljs-attribute\">-webkit-box-shadow</span>:<span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">#888</span>;\n    <span class=\"hljs-attribute\">-webkit-transform</span>:<span class=\"hljs-built_in\">rotate</span>(-45deg);\n    <span class=\"hljs-attribute\">-moz-box-shadow</span>: <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">#888</span>;\n    <span class=\"hljs-attribute\">-moz-transform</span>:<span class=\"hljs-built_in\">rotate</span>(-45deg);\n    <span class=\"hljs-attribute\">position</span>: absolute;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">150px</span>;\n    <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50px</span>;\n    <span class=\"hljs-attribute\">left</span>: -<span class=\"hljs-number\">120px</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n}\n<span class=\"hljs-selector-tag\">nav</span>{\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">25%</span>;\n    <span class=\"hljs-attribute\">float</span>:left;\n}\n<span class=\"hljs-selector-tag\">nav</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:link</span>, <span class=\"hljs-selector-tag\">nav</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:visited</span>{\n    <span class=\"hljs-attribute\">display</span>:block;\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#F47D31</span>;\n    <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">3px</span> solid <span class=\"hljs-number\">#FFFFFF</span>;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">text-decoration</span>: none;\n    <span class=\"hljs-attribute\">font-weight</span>: bold;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">5px</span>;\n}\n<span class=\"hljs-selector-tag\">nav</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span>{\n    <span class=\"hljs-attribute\">color</span>: white;\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#F47D31</span>;\n}\n<span class=\"hljs-selector-tag\">nav</span> <span class=\"hljs-selector-tag\">h3</span>{\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>;\n    <span class=\"hljs-attribute\">color</span>: white;\n}\n<span class=\"hljs-selector-id\">#container</span>{\n    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#888888</span>;\n}\n<span class=\"hljs-selector-tag\">section</span>{\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50%</span>;\n    <span class=\"hljs-attribute\">float</span>:left;\n}\n<span class=\"hljs-selector-tag\">article</span>{\n    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#eee</span>;\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-comment\">/*\n    -webkit-border-radius: 10px;\n    -moz-border-radius: 10px;\n    */</span>\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-comment\">/*-webkit-box-shadow:2px 2px 20px #888;*/</span>\n    <span class=\"hljs-comment\">/*-webkit-transform:rotate(-10deg);*/</span>\n    <span class=\"hljs-comment\">/*-moz-box-shadow:2px 2px 20px #888;*/</span>\n    <span class=\"hljs-comment\">/*-moz-transform:rotate(-10deg);*/</span>\n    <span class=\"hljs-attribute\">transform</span>:<span class=\"hljs-built_in\">rotate</span>(-10deg);\n    <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">#888</span>;\n}\n<span class=\"hljs-selector-tag\">article</span> <span class=\"hljs-selector-tag\">header</span>{\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">5px</span>;\n}\n<span class=\"hljs-selector-tag\">article</span> <span class=\"hljs-selector-tag\">footer</span>{\n    <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">5px</span>;\n}\n<span class=\"hljs-selector-tag\">article</span> <span class=\"hljs-selector-tag\">h1</span>{\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;\n}\n<span class=\"hljs-selector-tag\">aside</span> {\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">25%</span>;\n    <span class=\"hljs-attribute\">float</span>: left;\n}\n<span class=\"hljs-selector-tag\">aside</span> <span class=\"hljs-selector-tag\">h3</span>{\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>;\n    <span class=\"hljs-attribute\">color</span>: white;\n}\n<span class=\"hljs-selector-tag\">aside</span> <span class=\"hljs-selector-tag\">p</span>{\n    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">15px</span>;\n    <span class=\"hljs-attribute\">color</span>: white;\n    <span class=\"hljs-attribute\">font-weight</span>: bold;\n    <span class=\"hljs-attribute\">font-style</span>: italic;\n}\n<span class=\"hljs-selector-tag\">footer</span>{\n    <span class=\"hljs-attribute\">clear</span>:both;\n    <span class=\"hljs-attribute\">display</span>: block;\n    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#F47D31</span>;\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#FFFFFF</span>;\n    <span class=\"hljs-attribute\">text-align</span>: center;\n    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span>;\n}\n<span class=\"hljs-selector-tag\">footer</span> <span class=\"hljs-selector-tag\">h2</span>{\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;\n    <span class=\"hljs-attribute\">color</span>: white;\n}\n</code></div></pre>\n<h2><a id=\"_143\"></a>效果：</h2>\n<p><img src=\"http://rfzh8op8d.hn-bkt.clouddn.com/4dc470a7-3699-42e3-a13b-e78c1e9a1c65.png\" alt=\"QQ截图20220806110640.png\" /></p>\n', '1555750866936598530');
INSERT INTO `ms_article_body` VALUES ('1555756550424039427', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n\n\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步：**添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：**在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：**添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n\n\n**第二步：**打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_132\"></a>2.2 编写一个Http接口</h2>\n<p>**第一步：**创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__162\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步：**添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>**第二步：**在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_214\"></a>2.4 打包为jar运行</h2>\n<p>**第一步：**添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p>**第二步：**打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p>**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_246\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__252\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1');
INSERT INTO `ms_article_body` VALUES ('1555770529204568066', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_136\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__166\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_218\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_249\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__255\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405909844724051969');
INSERT INTO `ms_article_body` VALUES ('1555770925713096705', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n\n\n此时的项目结构为：\n\n\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p>此时的项目结构为：</p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_136\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__166\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_218\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_249\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__255\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405909844724051969');
INSERT INTO `ms_article_body` VALUES ('1555778880919470082', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ping www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">tracert www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">arp -a <span class=\"hljs-comment\">//查看缓存</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig/release<span class=\"hljs-comment\">// 会使计算机断网</span>\nipconfig/renew<span class=\"hljs-comment\">//使计算机恢复网络。</span>\n</code></div></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\"> netstat -an <span class=\"hljs-comment\">//**查看计算机当前的网络连接状况**</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig /displaydns  <span class=\"hljs-comment\">//查看解析过的 DNS 记录</span>\npconfig /flushdns <span class=\"hljs-comment\">//来清除所有的 DNS 缓存。</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">pc0上  ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.3</span>(PC1)的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">PC1上ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.2</span>（PC0）的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">在PC0和PC1上ping网关地址<span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1555780122211155970', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ping www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">tracert www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">arp -a <span class=\"hljs-comment\">//查看缓存</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig/release<span class=\"hljs-comment\">// 会使计算机断网</span>\nipconfig/renew<span class=\"hljs-comment\">//使计算机恢复网络。</span>\n</code></div></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\"> netstat -an <span class=\"hljs-comment\">//**查看计算机当前的网络连接状况**</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig /displaydns  <span class=\"hljs-comment\">//查看解析过的 DNS 记录</span>\npconfig /flushdns <span class=\"hljs-comment\">//来清除所有的 DNS 缓存。</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">pc0上  ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.3</span>(PC1)的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">PC1上ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.2</span>（PC0）的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">在PC0和PC1上ping网关地址<span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1555780260920983554', '# 1. Spring Boot介绍\n\n## 1.1 简介ll\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n\n\n此时的项目结构为：\n\n\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11_ll_2\"></a>1.1 简介ll</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p>此时的项目结构为：</p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_136\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__166\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_218\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_249\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__255\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405909844724051969');
INSERT INTO `ms_article_body` VALUES ('1555780351882854402', '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n\n\n此时的项目结构为：\n\n\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p>此时的项目结构为：</p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_136\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__166\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_218\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_249\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__255\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', '1405909844724051969');
INSERT INTO `ms_article_body` VALUES ('1558042675814924290', '### 1.0  java分为八种基本数据类型：\n> byte（Byte），short（Short），int（Integer）4，long（Long）8，float（Float）4，double（Double）8，bollean（Bollean），char（character）2.\n\n### 2.0 switch在java中能否做String为参数\n> switch语句中变量类型可以使用byte，short，int，char。从jdk1.7以后，可以使用String.hashcode将String类型数据转换为int进行判断。\n\n### 3.0 equals与==的区别：\n> ==操作符用来比较两个变量的值是否相等，及比较变量在内存中的存储地址是否相等。二equals（）方法是String类从object类继承的，被用来比较两个对象的内容是否相同。\n### 4.0 objec有哪些公用的方法：\n> 1.clone（创建并返回对象的副本），2equals（判断内容是否相同），3getClass（返回object的运行类），4hashCode（返回对象的哈希码值），5notify（唤醒正在等待对象监听器的单个进程），6notifyAll（唤醒正在等待对象监听器的所有进程），7wait（导致当前线程堵塞，直到另一线程调用该对象的notify（）方法或notifyAll（），8toString（返回此对象的字符串表达式），\n9finalize（）当垃圾收集器确定不需要该对象时，垃圾回收器将调用该方法。\n\n### 5.java的四种引用方式：强弱软虚，用到场景。\n>强引用：垃圾回收器不会回收。软引用：如果内存空间不足，垃圾回收器将调用该方法进行空间的回收，如果内存空间充足，垃圾回收器不会回收。弱引用：一旦发现只有弱引用对象，垃圾回器就会进行回收。虚引用：如果发现该对象还具有虚引用，就会在回收该对象前，将该虚引用加入到与之相关的引用队列。\n### 6.静态变量与实例变量有什么区别：\n> 静态变量前要加static关键字，实例变量则不用，实例变量使属于某个对象的属性，必须创建该对象后，才会为实例变量分配空间，我们才能使用。静态变量不属于任何实例对像，而是属于类，也称为类变量，只要程序加载了类的字节码信息，不用创建任何实例对象，就分配空间。总之就是静态变量不需要创建任何对象就能直接使用，而实例变量需要创建实例对象后才能使用。\n### 7. Overload与Override的区别：\n>重载overload表示同一个类中可以有多个相同名称的函数方法，但这些方法的参数列表不同，即参数的个数与类型可以不同，重载的返回值当然可以不同，但是如果参数列表相同既不能通过返回值的不同而实现重载，这是不可以的。重写override表示子类中方法可以与父类方法的名称和参数完全相同，通过子类创建对象调用这个方法时，将调用子类定义的方法，即子类的方法将父类的方法覆盖，但是只能抛出比父类更小或更少的异常。重写方法的返回值必须与父类一致。\n### 8.抽象类与接口的区别：\n> 抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在类中添加实现的方法的接口没有默认方法上进行实现，没有构造器，不可以使用main方法进行运行，在接口添加方法时需要在具体的实现类中添加实现方法。\n### 9.String，StringBufer与StringBuilder的区别：\n> String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）和hashCode（）方法，而StringBuffer没有覆盖这些方法，所以StringBuffer在存储对象到java集合类中会出现问题。\n StringBuilder也表示内容可以修改的字符串，但是线程是不安全的，效率是极高的。\n### 10.Java面向对象的特征与含义:封装，继承，抽象，多态。\n> 1.封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动的影响。封装是保证吧同一事物进行操作的方法和相关方法放在同一个类中，把方法和他操作的数据放在同一个类中。\n2.抽象：抽象就是找出事物的相似与共性，然后将这些食物归为一类，这个内只考虑这些事物的相似于与共性,忽略与当前主题无关的因素。\n3.继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者修改父类的内容而适合更加特殊的需要，提高了额程序的可重用性和可扩张性。\n4.多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时斌不确定，而是在程序运行期间才确定的，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法，必须由程序在运行期间才能确定。\n### 11.java多态的实现： \n>接口的实现，子类继承父类进行方法的重写，同一个类中进行方法的重载。\n### 12.error和exception的区别：\n>error表示程序运行过程中有可能恢复但回复比较困难的非正常状态，运行时异常表示虚拟机通常操作中可能遇到到异常，是一种常见的运行错误。Java编译器要求方法必须声明抛出可能出现的非运行时异常，但并不要求抛出声明未捕获的异常。\n### 13.java中的异常处理机制和简单原理的应用\n>Java程序违反了java语义规则时，java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括两种情况。一种java内库内置的语义检测。例如数组下标越界，就会引发IndexOutOfBoundsException；访问null对象就会引发NullPointException。另一种情况就是java允许程序员扩展这种语义检测，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发自己的异常。所有的异常都是java.lang.Throwable的子类。\n### 14.JAVA语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗？\n> Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供良好的接口。在java中，每个异常都是一个对象，它是Throwable类或其他子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象包含所有异常信息，调用这个方法对象可以捕获这个异常斌进行处理。Java的异常处理通过5个关键词来实现的。Try catch、throws，throw和finally。一般情况下用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。\n用try来指定一块预防所有的异常程序，紧跟在try的后面，应包含一个catch的字句来指定你想要的捕捉的异常类型。\nThrow语句用来明确地抛出异常。Throws用来标明一个成员函数可能抛出的各种异常。Finally用来确保一段代码不管发生什么异常都被执行的一段代码。\n可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，“异常”的框架就放到堆栈上面，直到所有的语句都完成。\n如果下一级的try语句没有对某种异常进行处理，堆栈就会展开，直到遇到有处理这种异常的try语句。', '<h3><a id=\"10__java_0\"></a>1.0  java分为八种基本数据类型：</h3>\n<blockquote>\n<p>byte（Byte），short（Short），int（Integer）4，long（Long）8，float（Float）4，double（Double）8，bollean（Bollean），char（character）2.</p>\n</blockquote>\n<h3><a id=\"20_switchjavaString_3\"></a>2.0 switch在java中能否做String为参数</h3>\n<blockquote>\n<p>switch语句中变量类型可以使用byte，short，int，char。从jdk1.7以后，可以使用String.hashcode将String类型数据转换为int进行判断。</p>\n</blockquote>\n<h3><a id=\"30_equals_6\"></a>3.0 equals与==的区别：</h3>\n<blockquote>\n<p>==操作符用来比较两个变量的值是否相等，及比较变量在内存中的存储地址是否相等。二equals（）方法是String类从object类继承的，被用来比较两个对象的内容是否相同。</p>\n</blockquote>\n<h3><a id=\"40_objec_8\"></a>4.0 objec有哪些公用的方法：</h3>\n<blockquote>\n<p>1.clone（创建并返回对象的副本），2equals（判断内容是否相同），3getClass（返回object的运行类），4hashCode（返回对象的哈希码值），5notify（唤醒正在等待对象监听器的单个进程），6notifyAll（唤醒正在等待对象监听器的所有进程），7wait（导致当前线程堵塞，直到另一线程调用该对象的notify（）方法或notifyAll（），8toString（返回此对象的字符串表达式），<br />\n9finalize（）当垃圾收集器确定不需要该对象时，垃圾回收器将调用该方法。</p>\n</blockquote>\n<h3><a id=\"5java_12\"></a>5.java的四种引用方式：强弱软虚，用到场景。</h3>\n<blockquote>\n<p>强引用：垃圾回收器不会回收。软引用：如果内存空间不足，垃圾回收器将调用该方法进行空间的回收，如果内存空间充足，垃圾回收器不会回收。弱引用：一旦发现只有弱引用对象，垃圾回器就会进行回收。虚引用：如果发现该对象还具有虚引用，就会在回收该对象前，将该虚引用加入到与之相关的引用队列。</p>\n</blockquote>\n<h3><a id=\"6_14\"></a>6.静态变量与实例变量有什么区别：</h3>\n<blockquote>\n<p>静态变量前要加static关键字，实例变量则不用，实例变量使属于某个对象的属性，必须创建该对象后，才会为实例变量分配空间，我们才能使用。静态变量不属于任何实例对像，而是属于类，也称为类变量，只要程序加载了类的字节码信息，不用创建任何实例对象，就分配空间。总之就是静态变量不需要创建任何对象就能直接使用，而实例变量需要创建实例对象后才能使用。</p>\n</blockquote>\n<h3><a id=\"7_OverloadOverride_16\"></a>7. Overload与Override的区别：</h3>\n<blockquote>\n<p>重载overload表示同一个类中可以有多个相同名称的函数方法，但这些方法的参数列表不同，即参数的个数与类型可以不同，重载的返回值当然可以不同，但是如果参数列表相同既不能通过返回值的不同而实现重载，这是不可以的。重写override表示子类中方法可以与父类方法的名称和参数完全相同，通过子类创建对象调用这个方法时，将调用子类定义的方法，即子类的方法将父类的方法覆盖，但是只能抛出比父类更小或更少的异常。重写方法的返回值必须与父类一致。</p>\n</blockquote>\n<h3><a id=\"8_18\"></a>8.抽象类与接口的区别：</h3>\n<blockquote>\n<p>抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在类中添加实现的方法的接口没有默认方法上进行实现，没有构造器，不可以使用main方法进行运行，在接口添加方法时需要在具体的实现类中添加实现方法。</p>\n</blockquote>\n<h3><a id=\"9StringStringBuferStringBuilder_20\"></a>9.String，StringBufer与StringBuilder的区别：</h3>\n<blockquote>\n<p>String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）和hashCode（）方法，而StringBuffer没有覆盖这些方法，所以StringBuffer在存储对象到java集合类中会出现问题。<br />\nStringBuilder也表示内容可以修改的字符串，但是线程是不安全的，效率是极高的。</p>\n</blockquote>\n<h3><a id=\"10Java_23\"></a>10.Java面向对象的特征与含义:封装，继承，抽象，多态。</h3>\n<blockquote>\n<p>1.封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动的影响。封装是保证吧同一事物进行操作的方法和相关方法放在同一个类中，把方法和他操作的数据放在同一个类中。<br />\n2.抽象：抽象就是找出事物的相似与共性，然后将这些食物归为一类，这个内只考虑这些事物的相似于与共性,忽略与当前主题无关的因素。<br />\n3.继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者修改父类的内容而适合更加特殊的需要，提高了额程序的可重用性和可扩张性。<br />\n4.多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时斌不确定，而是在程序运行期间才确定的，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法，必须由程序在运行期间才能确定。</p>\n</blockquote>\n<h3><a id=\"11java_28\"></a>11.java多态的实现：</h3>\n<blockquote>\n<p>接口的实现，子类继承父类进行方法的重写，同一个类中进行方法的重载。</p>\n</blockquote>\n<h3><a id=\"12errorexception_30\"></a>12.error和exception的区别：</h3>\n<blockquote>\n<p>error表示程序运行过程中有可能恢复但回复比较困难的非正常状态，运行时异常表示虚拟机通常操作中可能遇到到异常，是一种常见的运行错误。Java编译器要求方法必须声明抛出可能出现的非运行时异常，但并不要求抛出声明未捕获的异常。</p>\n</blockquote>\n<h3><a id=\"13java_32\"></a>13.java中的异常处理机制和简单原理的应用</h3>\n<blockquote>\n<p>Java程序违反了java语义规则时，java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括两种情况。一种java内库内置的语义检测。例如数组下标越界，就会引发IndexOutOfBoundsException；访问null对象就会引发NullPointException。另一种情况就是java允许程序员扩展这种语义检测，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发自己的异常。所有的异常都是java.lang.Throwable的子类。</p>\n</blockquote>\n<h3><a id=\"14JAVAthrowsthrowtry_catch_finallytry_34\"></a>14.JAVA语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗？</h3>\n<blockquote>\n<p>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供良好的接口。在java中，每个异常都是一个对象，它是Throwable类或其他子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象包含所有异常信息，调用这个方法对象可以捕获这个异常斌进行处理。Java的异常处理通过5个关键词来实现的。Try catch、throws，throw和finally。一般情况下用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br />\n用try来指定一块预防所有的异常程序，紧跟在try的后面，应包含一个catch的字句来指定你想要的捕捉的异常类型。<br />\nThrow语句用来明确地抛出异常。Throws用来标明一个成员函数可能抛出的各种异常。Finally用来确保一段代码不管发生什么异常都被执行的一段代码。<br />\n可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，“异常”的框架就放到堆栈上面，直到所有的语句都完成。<br />\n如果下一级的try语句没有对某种异常进行处理，堆栈就会展开，直到遇到有处理这种异常的try语句。</p>\n</blockquote>\n', '1558042675785564161');
INSERT INTO `ms_article_body` VALUES ('1558075069192273922', '## Spring核心原理\n### 什么是spring原理呢？\nspring两大核心是IOC（控制反转）和Aop（面向想切面编程）DI（依赖注入）。IOC的意思是控制反转，是指创建对象的控制权的转移，以前我们创建对象的主动权和实际的把握有自己把控而现在这种权利转移给spring容器，并由容器根据配置文件创建实例和管理各个实例之间的依赖关系，对象域对象之间是松散耦合也利于功能的复用，最直观的表达我们现在创建对象不用自己去new了，有spring容器根据我们提供的配置文件自动生产，我们需要对象时，直接从spring容器中获取即可。\n >  Spring配置文件配置的是类的字节码的位置及信息，容器生成的时候加载配置文件识别字节码信息，通过反射创建类的对象。\n  Spring提供IOC三种依赖注入方式：构造器注入，setter方法注入，根据注解注入。\n  DI的意思是依赖注入和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖ioc容器来动态注入对象所需要的资源。\n  \n### AOP\n> 一般称为面向切面编程\n作为面向对象对象的一种补充，用于将那些与业务无关，但对多个对象产生影响的公共行为与逻辑，抽取并封装为一个可重用的模块，这个模块被称为切面，SpringAop采用动态代理，所谓动态代理即是aop框架不去修改原字节码信息，而是每次在程序运行时在内存临时为方法创建一个aop对象，该对象包含了目标对象的全部方法，并针对特定的切点做了增强处理。SpringAop动态代理分为两种：Jdk动态代理和CGLIB动态代理。\n   ### Jdk动态代理\n>只提供接口代理，不支持类代理，核心是InvocationHandler接口和proxy类，InvocationHandler通过invoke（）函数方法反射调用目标类的代码，动态将横切逻辑与业务编织在一起，proxy类利用invocationHandler函数动态创建某一符号，某一接口实例，生成目标类的代理对象。\n### CGLIB动态代理\n >如果代理类没有实invocationhandler接口，那么SpringAop会选择CGLIB来动态代理目标类，CGLIB，是一个代码生成的类库，可以在程序运行时动态地生成指定类的一个子类对象，并覆盖其中的特定方法并添加增强代码，从而实现aop。CGLIB是通过继承方法做动态代理的，因此如果某一个类被标记为final，那么它是无法使用CGLIB做动态代理的。\n', '<h2><a id=\"Spring_0\"></a>Spring核心原理</h2>\n<h3><a id=\"spring_1\"></a>什么是spring原理呢？</h3>\n<p>spring两大核心是IOC（控制反转）和Aop（面向想切面编程）DI（依赖注入）。IOC的意思是控制反转，是指创建对象的控制权的转移，以前我们创建对象的主动权和实际的把握有自己把控而现在这种权利转移给spring容器，并由容器根据配置文件创建实例和管理各个实例之间的依赖关系，对象域对象之间是松散耦合也利于功能的复用，最直观的表达我们现在创建对象不用自己去new了，有spring容器根据我们提供的配置文件自动生产，我们需要对象时，直接从spring容器中获取即可。</p>\n<blockquote>\n<p>Spring配置文件配置的是类的字节码的位置及信息，容器生成的时候加载配置文件识别字节码信息，通过反射创建类的对象。<br />\nSpring提供IOC三种依赖注入方式：构造器注入，setter方法注入，根据注解注入。<br />\nDI的意思是依赖注入和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖ioc容器来动态注入对象所需要的资源。</p>\n</blockquote>\n<h3><a id=\"AOP_7\"></a>AOP</h3>\n<blockquote>\n<p>一般称为面向切面编程<br />\n作为面向对象对象的一种补充，用于将那些与业务无关，但对多个对象产生影响的公共行为与逻辑，抽取并封装为一个可重用的模块，这个模块被称为切面，SpringAop采用动态代理，所谓动态代理即是aop框架不去修改原字节码信息，而是每次在程序运行时在内存临时为方法创建一个aop对象，该对象包含了目标对象的全部方法，并针对特定的切点做了增强处理。SpringAop动态代理分为两种：Jdk动态代理和CGLIB动态代理。</p>\n</blockquote>\n<h3><a id=\"Jdk_10\"></a>Jdk动态代理</h3>\n<blockquote>\n<p>只提供接口代理，不支持类代理，核心是InvocationHandler接口和proxy类，InvocationHandler通过invoke（）函数方法反射调用目标类的代码，动态将横切逻辑与业务编织在一起，proxy类利用invocationHandler函数动态创建某一符号，某一接口实例，生成目标类的代理对象。</p>\n</blockquote>\n<h3><a id=\"CGLIB_12\"></a>CGLIB动态代理</h3>\n<blockquote>\n<p>如果代理类没有实invocationhandler接口，那么SpringAop会选择CGLIB来动态代理目标类，CGLIB，是一个代码生成的类库，可以在程序运行时动态地生成指定类的一个子类对象，并覆盖其中的特定方法并添加增强代码，从而实现aop。CGLIB是通过继承方法做动态代理的，因此如果某一个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>\n</blockquote>\n', '1558075068965781505');
INSERT INTO `ms_article_body` VALUES ('1558397539745071106', '### 1.0  java分为八种基本数据类型：\n> byte（Byte），short（Short），int（Integer）4，long（Long）8，float（Float）4，double（Double）8，bollean（Bollean），char（character）2.\n\n### 2.0 switch在java中能否做String为参数\n> switch语句中变量类型可以使用byte，short，int，char。从jdk1.7以后，可以使用String.hashcode将String类型数据转换为int进行判断。\n\n### 3.0 equals与==的区别：\n> ==操作符用来比较两个变量的值是否相等，及比较变量在内存中的存储地址是否相等。二equals（）方法是String类从object类继承的，被用来比较两个对象的内容是否相同。\n### 4.0 objec有哪些公用的方法：\n> 1.clone（创建并返回对象的副本），2equals（判断内容是否相同），3getClass（返回object的运行类），4hashCode（返回对象的哈希码值），5notify（唤醒正在等待对象监听器的单个进程），6notifyAll（唤醒正在等待对象监听器的所有进程），7wait（导致当前线程堵塞，直到另一线程调用该对象的notify（）方法或notifyAll（），8toString（返回此对象的字符串表达式），\n9finalize（）当垃圾收集器确定不需要该对象时，垃圾回收器将调用该方法。\n\n### 5.java的四种引用方式：强弱软虚，用到场景。\n>强引用：垃圾回收器不会回收。软引用：如果内存空间不足，垃圾回收器将调用该方法进行空间的回收，如果内存空间充足，垃圾回收器不会回收。弱引用：一旦发现只有弱引用对象，垃圾回器就会进行回收。虚引用：如果发现该对象还具有虚引用，就会在回收该对象前，将该虚引用加入到与之相关的引用队列。\n### 6.静态变量与实例变量有什么区别：\n> 静态变量前要加static关键字，实例变量则不用，实例变量使属于某个对象的属性，必须创建该对象后，才会为实例变量分配空间，我们才能使用。静态变量不属于任何实例对像，而是属于类，也称为类变量，只要程序加载了类的字节码信息，不用创建任何实例对象，就分配空间。总之就是静态变量不需要创建任何对象就能直接使用，而实例变量需要创建实例对象后才能使用。\n### 7. Overload与Override的区别：\n>重载overload表示同一个类中可以有多个相同名称的函数方法，但这些方法的参数列表不同，即参数的个数与类型可以不同，重载的返回值当然可以不同，但是如果参数列表相同既不能通过返回值的不同而实现重载，这是不可以的。重写override表示子类中方法可以与父类方法的名称和参数完全相同，通过子类创建对象调用这个方法时，将调用子类定义的方法，即子类的方法将父类的方法覆盖，但是只能抛出比父类更小或更少的异常。重写方法的返回值必须与父类一致。\n### 8.抽象类与接口的区别：\n> 抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在类中添加实现的方法的接口没有默认方法上进行实现，没有构造器，不可以使用main方法进行运行，在接口添加方法时需要在具体的实现类中添加实现方法。\n### 9.String，StringBufer与StringBuilder的区别：\n> String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）和hashCode（）方法，而StringBuffer没有覆盖这些方法，所以StringBuffer在存储对象到java集合类中会出现问题。\n StringBuilder也表示内容可以修改的字符串，但是线程是不安全的，效率是极高的。\n### 10.Java面向对象的特征与含义:封装，继承，抽象，多态。\n> 1.封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动的影响。封装是保证吧同一事物进行操作的方法和相关方法放在同一个类中，把方法和他操作的数据放在同一个类中。\n2.抽象：抽象就是找出事物的相似与共性，然后将这些食物归为一类，这个内只考虑这些事物的相似于与共性,忽略与当前主题无关的因素。\n3.继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者修改父类的内容而适合更加特殊的需要，提高了额程序的可重用性和可扩张性。\n4.多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时斌不确定，而是在程序运行期间才确定的，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法，必须由程序在运行期间才能确定。\n### 11.java多态的实现： \n>接口的实现，子类继承父类进行方法的重写，同一个类中进行方法的重载。\n### 12.error和exception的区别：\n>error表示程序运行过程中有可能恢复但回复比较困难的非正常状态，运行时异常表示虚拟机通常操作中可能遇到到异常，是一种常见的运行错误。Java编译器要求方法必须声明抛出可能出现的非运行时异常，但并不要求抛出声明未捕获的异常。\n### 13.java中的异常处理机制和简单原理的应用\n>Java程序违反了java语义规则时，java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括两种情况。一种java内库内置的语义检测。例如数组下标越界，就会引发IndexOutOfBoundsException；访问null对象就会引发NullPointException。另一种情况就是java允许程序员扩展这种语义检测，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发自己的异常。所有的异常都是java.lang.Throwable的子类。\n### 14.JAVA语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗？\n> Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供良好的接口。在java中，每个异常都是一个对象，它是Throwable类或其他子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象包含所有异常信息，调用这个方法对象可以捕获这个异常斌进行处理。Java的异常处理通过5个关键词来实现的。Try catch、throws，throw和finally。一般情况下用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。\n用try来指定一块预防所有的异常程序，紧跟在try的后面，应包含一个catch的字句来指定你想要的捕捉的异常类型。\nThrow语句用来明确地抛出异常。Throws用来标明一个成员函数可能抛出的各种异常。Finally用来确保一段代码不管发生什么异常都被执行的一段代码。\n可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，“异常”的框架就放到堆栈上面，直到所有的语句都完成。\n如果下一级的try语句没有对某种异常进行处理，堆栈就会展开，直到遇到有处理这种异常的try语句。\n### 15.try catch finally ，try里有return，finally还执行吗？\n>1.finally语句总会执行。\n2.如果try catch中有return语句，finally中没有return，那么在finall中除修改包装类型和静态变量，全局变量以外的数据都不会对try catch中返回变量有任何的影响（包装类型，静态变量会改变，全局变量）\n3.尽量不要在finall使用return语句，如果使用的话return语句，如果使用的话，会忽略try catch中的返回语句，也会忽略try catch里的异常，评比错误的发生。\n4.Finally避免抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try catch中异常将会被忽略。\n### 16.java中的final，finally和finalize的区别：\n>Final用于声明属性，方法和类，分别表示属性不可改变，方法不可覆盖，类不能继承。\n内部要访问局部变量，局部变量必须定义成final类型，如，一段代码。\nFinally是异常处理结构的一部分，表示总会执行。\nFinalize是object类的一个方法，在垃圾收集器执行的时候会调用被回对象的此方法，可以覆盖此方法提供垃圾收集器的其他资源回收，例如关闭文件等。Jvm不保证此方法总被调用。\n### 17.hashmap，linkedhashmap，treemap的区别\n>1.hashmap是根据键的hashcode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，取得的数据完全是随机的。\n2.linkedHashmap保存了记录的插入顺序，在使用itrector进行遍历的时候，先得到的肯定是先插入的数据，可以在构造时带参数，按照应用次数来进行排序。\n3.treeMap实现SortMap接口，能够把它保存的记录根据键排序，默认升序排列，也可以指定排序的比较器，进行遍历的时候得到的是排序过的记录。\n', '<h3><a id=\"10__java_0\"></a>1.0  java分为八种基本数据类型：</h3>\n<blockquote>\n<p>byte（Byte），short（Short），int（Integer）4，long（Long）8，float（Float）4，double（Double）8，bollean（Bollean），char（character）2.</p>\n</blockquote>\n<h3><a id=\"20_switchjavaString_3\"></a>2.0 switch在java中能否做String为参数</h3>\n<blockquote>\n<p>switch语句中变量类型可以使用byte，short，int，char。从jdk1.7以后，可以使用String.hashcode将String类型数据转换为int进行判断。</p>\n</blockquote>\n<h3><a id=\"30_equals_6\"></a>3.0 equals与==的区别：</h3>\n<blockquote>\n<p>==操作符用来比较两个变量的值是否相等，及比较变量在内存中的存储地址是否相等。二equals（）方法是String类从object类继承的，被用来比较两个对象的内容是否相同。</p>\n</blockquote>\n<h3><a id=\"40_objec_8\"></a>4.0 objec有哪些公用的方法：</h3>\n<blockquote>\n<p>1.clone（创建并返回对象的副本），2equals（判断内容是否相同），3getClass（返回object的运行类），4hashCode（返回对象的哈希码值），5notify（唤醒正在等待对象监听器的单个进程），6notifyAll（唤醒正在等待对象监听器的所有进程），7wait（导致当前线程堵塞，直到另一线程调用该对象的notify（）方法或notifyAll（），8toString（返回此对象的字符串表达式），<br />\n9finalize（）当垃圾收集器确定不需要该对象时，垃圾回收器将调用该方法。</p>\n</blockquote>\n<h3><a id=\"5java_12\"></a>5.java的四种引用方式：强弱软虚，用到场景。</h3>\n<blockquote>\n<p>强引用：垃圾回收器不会回收。软引用：如果内存空间不足，垃圾回收器将调用该方法进行空间的回收，如果内存空间充足，垃圾回收器不会回收。弱引用：一旦发现只有弱引用对象，垃圾回器就会进行回收。虚引用：如果发现该对象还具有虚引用，就会在回收该对象前，将该虚引用加入到与之相关的引用队列。</p>\n</blockquote>\n<h3><a id=\"6_14\"></a>6.静态变量与实例变量有什么区别：</h3>\n<blockquote>\n<p>静态变量前要加static关键字，实例变量则不用，实例变量使属于某个对象的属性，必须创建该对象后，才会为实例变量分配空间，我们才能使用。静态变量不属于任何实例对像，而是属于类，也称为类变量，只要程序加载了类的字节码信息，不用创建任何实例对象，就分配空间。总之就是静态变量不需要创建任何对象就能直接使用，而实例变量需要创建实例对象后才能使用。</p>\n</blockquote>\n<h3><a id=\"7_OverloadOverride_16\"></a>7. Overload与Override的区别：</h3>\n<blockquote>\n<p>重载overload表示同一个类中可以有多个相同名称的函数方法，但这些方法的参数列表不同，即参数的个数与类型可以不同，重载的返回值当然可以不同，但是如果参数列表相同既不能通过返回值的不同而实现重载，这是不可以的。重写override表示子类中方法可以与父类方法的名称和参数完全相同，通过子类创建对象调用这个方法时，将调用子类定义的方法，即子类的方法将父类的方法覆盖，但是只能抛出比父类更小或更少的异常。重写方法的返回值必须与父类一致。</p>\n</blockquote>\n<h3><a id=\"8_18\"></a>8.抽象类与接口的区别：</h3>\n<blockquote>\n<p>抽象类可以有默认的方法进行实现，可以有构造器，可以有main方法进行运行，可以直接在类中添加实现的方法的接口没有默认方法上进行实现，没有构造器，不可以使用main方法进行运行，在接口添加方法时需要在具体的实现类中添加实现方法。</p>\n</blockquote>\n<h3><a id=\"9StringStringBuferStringBuilder_20\"></a>9.String，StringBufer与StringBuilder的区别：</h3>\n<blockquote>\n<p>String表示内容不可修改的字符串，StringBuffer表示内容可以修改的字符串，String覆盖了equals（）和hashCode（）方法，而StringBuffer没有覆盖这些方法，所以StringBuffer在存储对象到java集合类中会出现问题。<br />\nStringBuilder也表示内容可以修改的字符串，但是线程是不安全的，效率是极高的。</p>\n</blockquote>\n<h3><a id=\"10Java_23\"></a>10.Java面向对象的特征与含义:封装，继承，抽象，多态。</h3>\n<blockquote>\n<p>1.封装：封装的目的在于实现程序的“高内聚，低耦合”，防止程序相互依赖而带来的变动的影响。封装是保证吧同一事物进行操作的方法和相关方法放在同一个类中，把方法和他操作的数据放在同一个类中。<br />\n2.抽象：抽象就是找出事物的相似与共性，然后将这些食物归为一类，这个内只考虑这些事物的相似于与共性,忽略与当前主题无关的因素。<br />\n3.继承：子类继承父类的内容作为自己的内容，可以加入新的内容或者修改父类的内容而适合更加特殊的需要，提高了额程序的可重用性和可扩张性。<br />\n4.多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时斌不确定，而是在程序运行期间才确定的，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法，必须由程序在运行期间才能确定。</p>\n</blockquote>\n<h3><a id=\"11java_28\"></a>11.java多态的实现：</h3>\n<blockquote>\n<p>接口的实现，子类继承父类进行方法的重写，同一个类中进行方法的重载。</p>\n</blockquote>\n<h3><a id=\"12errorexception_30\"></a>12.error和exception的区别：</h3>\n<blockquote>\n<p>error表示程序运行过程中有可能恢复但回复比较困难的非正常状态，运行时异常表示虚拟机通常操作中可能遇到到异常，是一种常见的运行错误。Java编译器要求方法必须声明抛出可能出现的非运行时异常，但并不要求抛出声明未捕获的异常。</p>\n</blockquote>\n<h3><a id=\"13java_32\"></a>13.java中的异常处理机制和简单原理的应用</h3>\n<blockquote>\n<p>Java程序违反了java语义规则时，java虚拟机就会将发生的错误表示为一个异常。违反语义规则包括两种情况。一种java内库内置的语义检测。例如数组下标越界，就会引发IndexOutOfBoundsException；访问null对象就会引发NullPointException。另一种情况就是java允许程序员扩展这种语义检测，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发自己的异常。所有的异常都是java.lang.Throwable的子类。</p>\n</blockquote>\n<h3><a id=\"14JAVAthrowsthrowtry_catch_finallytry_34\"></a>14.JAVA语言如何进行异常处理，throws，throw，try catch finally代表什么意义，try块中可以抛出异常吗？</h3>\n<blockquote>\n<p>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供良好的接口。在java中，每个异常都是一个对象，它是Throwable类或其他子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象包含所有异常信息，调用这个方法对象可以捕获这个异常斌进行处理。Java的异常处理通过5个关键词来实现的。Try catch、throws，throw和finally。一般情况下用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br />\n用try来指定一块预防所有的异常程序，紧跟在try的后面，应包含一个catch的字句来指定你想要的捕捉的异常类型。<br />\nThrow语句用来明确地抛出异常。Throws用来标明一个成员函数可能抛出的各种异常。Finally用来确保一段代码不管发生什么异常都被执行的一段代码。<br />\n可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，“异常”的框架就放到堆栈上面，直到所有的语句都完成。<br />\n如果下一级的try语句没有对某种异常进行处理，堆栈就会展开，直到遇到有处理这种异常的try语句。</p>\n</blockquote>\n<h3><a id=\"15try_catch_finally_tryreturnfinally_40\"></a>15.try catch finally ，try里有return，finally还执行吗？</h3>\n<blockquote>\n<p>1.finally语句总会执行。<br />\n2.如果try catch中有return语句，finally中没有return，那么在finall中除修改包装类型和静态变量，全局变量以外的数据都不会对try catch中返回变量有任何的影响（包装类型，静态变量会改变，全局变量）<br />\n3.尽量不要在finall使用return语句，如果使用的话return语句，如果使用的话，会忽略try catch中的返回语句，也会忽略try catch里的异常，评比错误的发生。<br />\n4.Finally避免抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try catch中异常将会被忽略。</p>\n</blockquote>\n<h3><a id=\"16javafinalfinallyfinalize_45\"></a>16.java中的final，finally和finalize的区别：</h3>\n<blockquote>\n<p>Final用于声明属性，方法和类，分别表示属性不可改变，方法不可覆盖，类不能继承。<br />\n内部要访问局部变量，局部变量必须定义成final类型，如，一段代码。<br />\nFinally是异常处理结构的一部分，表示总会执行。<br />\nFinalize是object类的一个方法，在垃圾收集器执行的时候会调用被回对象的此方法，可以覆盖此方法提供垃圾收集器的其他资源回收，例如关闭文件等。Jvm不保证此方法总被调用。</p>\n</blockquote>\n<h3><a id=\"17hashmaplinkedhashmaptreemap_50\"></a>17.hashmap，linkedhashmap，treemap的区别</h3>\n<blockquote>\n<p>1.hashmap是根据键的hashcode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，取得的数据完全是随机的。<br />\n2.linkedHashmap保存了记录的插入顺序，在使用itrector进行遍历的时候，先得到的肯定是先插入的数据，可以在构造时带参数，按照应用次数来进行排序。<br />\n3.treeMap实现SortMap接口，能够把它保存的记录根据键排序，默认升序排列，也可以指定排序的比较器，进行遍历的时候得到的是排序过的记录。</p>\n</blockquote>\n', '1558042675785564161');
INSERT INTO `ms_article_body` VALUES ('1558406356943831042', '## 一、Mabatis一级缓存\n### 1.简介：\n>一级缓存作用域是sqlSession级别的，同一个sqlsession中执行相同的sql语句查询（相同的sql和参数），第一次会查询数据库并写入到缓存，第二次从一级缓存中取。\n一级缓存是基于PerpeturalCash的hashMap本地缓存，默认打开一级缓存。\n### 2.何时清空一级缓存\n>如果中间的sqlsession中执行commit操作（执行插入，更新，删除），则会清空SqlSession的一级缓存，这样做的目的为了让缓存中的数据总是最新的数据，避免数据库的脏读。\n### 3.一级缓存无过期时间，只有生命周期\n>MyBatis在开启一个数据库会话时，会创建一个新的SqlSessin对象，SqlSessin对象会有一个Executor对象，Executor对象持有一个PerpetualCatche对象，当会话结束时，SqlSession对象及其内部的Executor对象还有perpetualCache对象也会一并释放。\n## 二、Mybatis的二级缓存\n### 1.二级缓存简介\n>他指的是mybatis中的SqlSessionFactory对象的缓存，由一个SqlSessionFactorty对象创建的SqlSession共享其缓存。\n二级缓存是mapper映射级别的缓存，多个SqlSession对象去操作同一个mapper级别的sql语句，多个sqlSessionn可以共用二级缓存，二级缓存是跨sqlSessiopn的。\n### 2.二级缓存何时存入\n>在关闭sqlSession后（close），才会把sqlSession一级缓存的数据添加到nameSpace的二级缓存中。\n开启二级缓存后，还需要将缓存的pojo实现Serializable接口，为了将缓存的数据取出执行反序列化操作，因为二级缓存数据存储介质对种多样，不一定只在内存中，有可能存在硬盘。\n### 3.二级缓存有过期时间，但没有后台进程进行检测\n>需要注意的是，并不是key-value的过期时间，而是这个cache过期的时间，是flushInterval，意味着整个清空缓存cache，所以不需要后台线程定期去检测。\n每当存储数据的时候，都要检测一下cache的生命周期，默认一小时，如果该cache存活了一个小时，那么将整个清空一下。\n当mybatis调用Dao层查询数据库时，先查询二级缓存，二级缓存中无对应的数据，再查询一级缓存的数据，一级缓存也没有，最后去数据库查找。', '<h2><a id=\"Mabatis_0\"></a>一、Mabatis一级缓存</h2>\n<h3><a id=\"1_1\"></a>1.简介：</h3>\n<blockquote>\n<p>一级缓存作用域是sqlSession级别的，同一个sqlsession中执行相同的sql语句查询（相同的sql和参数），第一次会查询数据库并写入到缓存，第二次从一级缓存中取。<br />\n一级缓存是基于PerpeturalCash的hashMap本地缓存，默认打开一级缓存。</p>\n</blockquote>\n<h3><a id=\"2_4\"></a>2.何时清空一级缓存</h3>\n<blockquote>\n<p>如果中间的sqlsession中执行commit操作（执行插入，更新，删除），则会清空SqlSession的一级缓存，这样做的目的为了让缓存中的数据总是最新的数据，避免数据库的脏读。</p>\n</blockquote>\n<h3><a id=\"3_6\"></a>3.一级缓存无过期时间，只有生命周期</h3>\n<blockquote>\n<p>MyBatis在开启一个数据库会话时，会创建一个新的SqlSessin对象，SqlSessin对象会有一个Executor对象，Executor对象持有一个PerpetualCatche对象，当会话结束时，SqlSession对象及其内部的Executor对象还有perpetualCache对象也会一并释放。</p>\n</blockquote>\n<h2><a id=\"Mybatis_8\"></a>二、Mybatis的二级缓存</h2>\n<h3><a id=\"1_9\"></a>1.二级缓存简介</h3>\n<blockquote>\n<p>他指的是mybatis中的SqlSessionFactory对象的缓存，由一个SqlSessionFactorty对象创建的SqlSession共享其缓存。<br />\n二级缓存是mapper映射级别的缓存，多个SqlSession对象去操作同一个mapper级别的sql语句，多个sqlSessionn可以共用二级缓存，二级缓存是跨sqlSessiopn的。</p>\n</blockquote>\n<h3><a id=\"2_12\"></a>2.二级缓存何时存入</h3>\n<blockquote>\n<p>在关闭sqlSession后（close），才会把sqlSession一级缓存的数据添加到nameSpace的二级缓存中。<br />\n开启二级缓存后，还需要将缓存的pojo实现Serializable接口，为了将缓存的数据取出执行反序列化操作，因为二级缓存数据存储介质对种多样，不一定只在内存中，有可能存在硬盘。</p>\n</blockquote>\n<h3><a id=\"3_15\"></a>3.二级缓存有过期时间，但没有后台进程进行检测</h3>\n<blockquote>\n<p>需要注意的是，并不是key-value的过期时间，而是这个cache过期的时间，是flushInterval，意味着整个清空缓存cache，所以不需要后台线程定期去检测。<br />\n每当存储数据的时候，都要检测一下cache的生命周期，默认一小时，如果该cache存活了一个小时，那么将整个清空一下。<br />\n当mybatis调用Dao层查询数据库时，先查询二级缓存，二级缓存中无对应的数据，再查询一级缓存的数据，一级缓存也没有，最后去数据库查找。</p>\n</blockquote>\n', '1558406356893499394');
INSERT INTO `ms_article_body` VALUES ('1558821583481012226', '@[toc]\n## 1.0验证性实验ipconfig\n###  1.使用 ipconfig/all 查看自己计算机的网络配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n### 2.0验证ping的联通性\n\n> PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。\n\n```cpp\nping www.baidu.com\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16)\n### 3.0验证tracert追踪节点\n\n> Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.\n\n```cpp\ntracert www.baidu.com\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16)\n### 4.0ARP查看缓存\n\n> ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。\n\n```cpp\narp -a //查看缓存\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16)\n### 5.0 DCHP\n\n> DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：\n>\n\n```cpp\nipconfig/release// 会使计算机断网\nipconfig/renew//使计算机恢复网络。\n```\n**断开网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n**重连上网络：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png)\n### 5.0 netstat\n\n> Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n> \n> \n\n```cpp\n netstat -an //**查看计算机当前的网络连接状况**\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16)\n### 6.0  DNS\n\n> DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；\n\n```cpp\nipconfig /displaydns  //查看解析过的 DNS 记录\npconfig /flushdns //来清除所有的 DNS 缓存。\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n## 2.0 wireshark实验\n### 2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。\n#### 2.1.1 打开wireshark进行抓包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.2 wireshark抓取指定的包\n\n> 抓取百度的包先查看自己的ip 192.168.43.205\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png)\n\n 1. **ping bai.du.com 等待它给予我们回复**\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n 2. **抓包**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n#### 2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n#### 2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n## 3.0 Cisco Packet Tracer实验\n### 1.0组建小型局域网\n\n> 实验任务\n        1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；\n        2、分别设置pc机的ip地址；\n         3、验证pc机间可以互通。\n>\n**1.0 实验设备**\n Switch_2960 1台；PC 2台；直连线\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**2.0 实验设备配置**\n> PC0\nIP：                192.168.1.2\nSubmask：     255.255.255.0\n Gateway：     192.168.1.1\n\n>PC1\n> IP：                192.168.1.3\nSubmask：     255.255.255.0\nGateway：     192.168.1.1\n\n**3.0 实验**\n\n```cpp\npc0上  ping 192.168.1.3(PC1)的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png)\n\n```cpp\nPC1上ping 192.168.1.2（PC0）的ip地址\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n```cpp\n在PC0和PC1上ping网关地址192.168.1.1\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png)\n### 2.0交换式以太网实验\n\n####  1.0 实验内容\n\n> 构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n\n\n\n#### 2.0 实验目的\n\n> 验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。\n验证转发表建立过程。\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。\n验证转发项与交换式以太网拓扑结构一致性的重要性。\n\n#### 3.0 验证过程\n1.0 按照实验要求构建网络拓扑结构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n\n2.0 终端A的基本配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n3.0 关闭CDP并清空MAC表\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png)\n4.0 终端A发送MAC帧到S1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16)\n5.0 S1创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n7.0 操作完成之后交换机中的MAC表分别为：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png)\n8.0  终端B向终端A发送MAC帧\n\n> S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16)\n完成上述操作各个交换机中的MAC表：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png)\n\n9.0 将终端A重新连接至S3上\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16)\n\n10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16)\n11.0 最后终端C向终端A发送MAC帧\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16)\n', '<p><h3>Table of Contents</h3><ul><ul><li><a href=\"#10ipconfig_1\">1.0验证性实验ipconfig</a></li><ul><li><a href=\"#1_ipconfigall__2\">1.使用 ipconfig/all 查看自己计算机的网络配置</a></li><li><a href=\"#20ping_4\">2.0验证ping的联通性</a></li><li><a href=\"#30tracert_15\">3.0验证tracert追踪节点</a></li><li><a href=\"#40ARP_23\">4.0ARP查看缓存</a></li><li><a href=\"#50_DCHP_32\">5.0 DCHP</a></li><li><a href=\"#50_netstat_46\">5.0 netstat</a></li><li><a href=\"#60__DNS_56\">6.0  DNS</a></li></ul><li><a href=\"#20_wireshark_65\">2.0 wireshark实验</a></li><ul><li><a href=\"#21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\">2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</a></li><ul><li><a href=\"#211_wireshark_67\">2.1.1 打开wireshark进行抓包</a></li><li><a href=\"#212_wireshark_70\">2.1.2 wireshark抓取指定的包</a></li><li><a href=\"#213_Ethernet__MAC_MAC_79\">2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</a></li><li><a href=\"#214_IP_TTL_81\">2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</a></li><li><a href=\"#215__Wireshark__tcp__TCP__83\">2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</a></li><li><a href=\"#216_Wireshark__udp__UDP__86\">2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</a></li></ul></ul><li><a href=\"#30_Cisco_Packet_Tracer_88\">3.0 Cisco Packet Tracer实验</a></li><ul><li><a href=\"#10_89\">1.0组建小型局域网</a></li><li><a href=\"#20_127\">2.0交换式以太网实验</a></li><ul><li><a href=\"#10__129\">1.0 实验内容</a></li><li><a href=\"#20__137\">2.0 实验目的</a></li><li><a href=\"#30__144\">3.0 验证过程</a></li></ul></ul></ul></ul></p>\n<h2><a id=\"10ipconfig_1\"></a>1.0验证性实验ipconfig</h2>\n<h3><a id=\"1_ipconfigall__2\"></a>1.使用 ipconfig/all 查看自己计算机的网络配置</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/91b7c0be11a4457f9f7a11737308d03c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20ping_4\"></a>2.0验证ping的联通性</h3>\n<blockquote>\n<p>PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。ping 是工作在 TCP/IP<br />\n网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message<br />\nProtocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ping www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/fea435426e94458b8a15903c5e86aa5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"30tracert_15\"></a>3.0验证tracert追踪节点</h3>\n<blockquote>\n<p>Tracert(跟踪路由)是路由跟踪实用程序，用于确定 IP数据包访问目标所采取的路径。Tracert 命令使用用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由.</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">tracert www.baidu.com\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/834fe1afebda4319b436f116ffade9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_17,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"40ARP_23\"></a>4.0ARP查看缓存</h3>\n<blockquote>\n<p>ARP（Address Resolution Protocol）即地址解析协议，是用于根据给定网络层地址即 IP<br />\n地址，查找并得到其对应的数据链路层地址即 MAC地址的协议。 ARP 协议定义在 1982 年的 RFC 826。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">arp -a <span class=\"hljs-comment\">//查看缓存</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ce9e108ba2d34396b01731c508019606.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_19,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_DCHP_32\"></a>5.0 DCHP</h3>\n<blockquote>\n<p>DHCP（Dynamic Host Configuration Protocol）即动态主机配置协议，是一个用于 IP<br />\n网络的网络协议，位于 OSI 模型的应用层，使用 UDP 协议工作，主要有两个用途：</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig/release<span class=\"hljs-comment\">// 会使计算机断网</span>\nipconfig/renew<span class=\"hljs-comment\">//使计算机恢复网络。</span>\n</code></div></pre>\n<p><strong>断开网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ce706f35b42c405b826c602cfb0b3a2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<strong>重连上网络：</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/761e223314484e3d9b4cdd917edeb945.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"50_netstat_46\"></a>5.0 netstat</h3>\n<blockquote>\n<p>Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\"> netstat -an <span class=\"hljs-comment\">//**查看计算机当前的网络连接状况**</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/709dbb8a31aa45708d2bf7697699c10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"60__DNS_56\"></a>6.0  DNS</h3>\n<blockquote>\n<p>DNS是计算机域名系统的缩写，是建立在分布式数据库上的分层命名系统，使用户更方便的访问互联网；</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">ipconfig /displaydns  <span class=\"hljs-comment\">//查看解析过的 DNS 记录</span>\npconfig /flushdns <span class=\"hljs-comment\">//来清除所有的 DNS 缓存。</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/906acb7af9b24296b687bd4677f7473e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"20_wireshark_65\"></a>2.0 wireshark实验</h2>\n<h3><a id=\"21___Ethernet__Wireshark__Ethernet__MAC_MAC_66\"></a>2.1  熟悉 Ethernet 帧结构使用 Wireshark 任意进行抓包，熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等。</h3>\n<h4><a id=\"211_wireshark_67\"></a>2.1.1 打开wireshark进行抓包</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/78b8234ab63343bca11cbf0ef13acf6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n<img src=\"https://img-blog.csdnimg.cn/dd571732b1fa4d3b9ebd70a1e10b4659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"212_wireshark_70\"></a>2.1.2 wireshark抓取指定的包</h4>\n<blockquote>\n<p>抓取百度的包先查看自己的ip 192.168.43.205<br />\n<img src=\"https://img-blog.csdnimg.cn/94c95b5bad4e42bfa2988123f1b03995.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<ol>\n<li><strong>ping bai.du.com 等待它给予我们回复</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/0b012a9912c645b3881f67846a9009e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></li>\n<li><strong>抓包</strong><br />\n<img src=\"https://img-blog.csdnimg.cn/ef79dec9290e4428b173353e06fc1f5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></li>\n</ol>\n<h4><a id=\"213_Ethernet__MAC_MAC_79\"></a>2.1.3熟悉 Ethernet 帧的结构，如：目的 MAC、源 MAC、类型、字段等</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/c2c9549affed435f9e7594ea46e81a75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"214_IP_TTL_81\"></a>2.1.4熟悉 IP 包的结构，如：版本、头部长度、总长度、TTL、协议类型等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/94dd35c16e6048edb650f75f0812b980.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"215__Wireshark__tcp__TCP__83\"></a>2.1.5 用 Wireshark 任意抓包（可用 tcp 过滤），熟悉 TCP 段的结构，如：源端口、目的端口、序列号、确认号、各种标志位等字段。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8d75cc917af449769294d584b459baf1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"216_Wireshark__udp__UDP__86\"></a>2.1.6用 Wireshark 任意抓包（可用 udp 过滤），熟悉 UDP 段的结构，如：源端口、目的端口、长度等。</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/8f8055d101f144dcb6b345c2ae2585ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"30_Cisco_Packet_Tracer_88\"></a>3.0 Cisco Packet Tracer实验</h2>\n<h3><a id=\"10_89\"></a>1.0组建小型局域网</h3>\n<blockquote>\n<p>实验任务<br />\n1、利用一台型号为2960的交换机将2pc机互连组建一个小型局域网；<br />\n2、分别设置pc机的ip地址；<br />\n3、验证pc机间可以互通。</p>\n</blockquote>\n<p><strong>1.0 实验设备</strong><br />\nSwitch_2960 1台；PC 2台；直连线<br />\n<img src=\"https://img-blog.csdnimg.cn/3c26e7a95caa4d84b7484b25dbb6dbe3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>2.0 实验设备配置</strong></p>\n<blockquote>\n<p>PC0<br />\nIP：                192.168.1.2<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<blockquote>\n<p>PC1<br />\nIP：                192.168.1.3<br />\nSubmask：     255.255.255.0<br />\nGateway：     192.168.1.1</p>\n</blockquote>\n<p><strong>3.0 实验</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">pc0上  ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.3</span>(PC1)的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ab69ae0c9a244de69ebdf504aba30b15.png\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">PC1上ping <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.2</span>（PC0）的ip地址\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2497ec5226ba42ba869ba768a3c0bfef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<pre><div class=\"hljs\"><code class=\"lang-cpp\">在PC0和PC1上ping网关地址<span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>\n</code></div></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/ad7bed52acaa4e729d3fa81ad696ff15.png\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"20_127\"></a>2.0交换式以太网实验</h3>\n<h4><a id=\"10__129\"></a>1.0 实验内容</h4>\n<blockquote>\n<p>构建如图所示的交换式以太网结构，在三个交换机的初始转发表为空的情况下，分别完成终端A与终端B、终端C和终端D之间的MAC帧传输过程，查看三个交换机的MAC表。清空交换机S1的MAC表，查看终端A与终端B之间的MAC帧传输过程。将终端A转接到交换机S3，查看终端B至终端A，终端C至终端A的MAC帧传输过程。<br />\n<img src=\"https://img-blog.csdnimg.cn/48ebf73580774d15b753d37272b2a35b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<h4><a id=\"20__137\"></a>2.0 实验目的</h4>\n<blockquote>\n<p>验证交换式以太网的连通性，证明连接在交换式以太网上的任何两个分配了相同网络号、不同主机号的IP地址的终端之间能够实现IP分组传输过程。<br />\n验证转发表建立过程。<br />\n验证交换机MAC帧转发过程，重点验证交换机过滤MAC帧的功能，即如果交换机接收MAC帧的端口与该MAC帧匹配的转发项中的转发端口相同，交换机丢弃该MAC帧。<br />\n验证转发项与交换式以太网拓扑结构一致性的重要性。</p>\n</blockquote>\n<h4><a id=\"30__144\"></a>3.0 验证过程</h4>\n<p>1.0 按照实验要求构建网络拓扑结构<br />\n<img src=\"https://img-blog.csdnimg.cn/7747a45a98574fb4a1374f854041eb8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>2.0 终端A的基本配置<br />\n<img src=\"https://img-blog.csdnimg.cn/e3d071bf8246435198d5ce2f4be875e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n3.0 关闭CDP并清空MAC表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66f9fbba74dd46cb80d9bc0321f06954.png\" alt=\"在这里插入图片描述\" /><br />\n4.0 终端A发送MAC帧到S1<br />\n<img src=\"https://img-blog.csdnimg.cn/6e11afd8c05748229e9caddae9dcd0c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_13,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n5.0 S1创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/197c14e6448f45e986b68ba6bced5f63.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n6.0 S2创建表型并广播MAC帧，当S3接收到MAC帧后，创建表项并广播MAC帧<br />\n<img src=\"https://img-blog.csdnimg.cn/ffea0b1067854883b95842b0536d8dac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n7.0 操作完成之后交换机中的MAC表分别为：<br />\n<img src=\"https://img-blog.csdnimg.cn/1978b46dd5744cc4a80ae573dd832059.png\" alt=\"在这里插入图片描述\" /><br />\n8.0  终端B向终端A发送MAC帧</p>\n<blockquote>\n<p>S1接收到终端B发送的MAC帧后，先创建至MACB的表项再广播该MAC帧；S2和S3接收到MAC帧后，先创建至MACB的表项再广播该MAC帧（如下图所示）；终端A接收到该MAC帧后，应答该MAC帧。<br />\n<img src=\"https://img-blog.csdnimg.cn/718c7793a2b446518e6570d278e9e92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_11,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n完成上述操作各个交换机中的MAC表：<br />\n<img src=\"https://img-blog.csdnimg.cn/8e7348267f6448799468a9dd7ca08f0d.png\" alt=\"在这里插入图片描述\" /></p>\n</blockquote>\n<p>9.0 将终端A重新连接至S3上</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a7a0ec8a3a0849819db049de25c13971.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_12,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n<p>10.0 终端B向终端A发送MAC帧当S2接收到MAC帧后丢弃该帧：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bfe26cf47c85448e9cd75dbf9984641d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_14,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /><br />\n11.0 最后终端C向终端A发送MAC帧</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a8ad833be8d24802827f4be7059296f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA4Ly626PbluC4tOiSstuj25bguLTpqo_gvJLbo9uW4Li04Ly7,size_9,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\" /></p>\n', '1405564731300831233');
INSERT INTO `ms_article_body` VALUES ('1560081784792219650', '1.首先浏览器发送请求-->DispatcherServLet前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局的流程控制：2.DispatcherServlet-->handlerMapping，处理器映射器将会把请求映射HandlerExecutionChain对象（包含一个handler处理器对象，多个HandlerInterceptor拦截器对象）3.DispatcherServlet-->HandlerAdapter,处理器适配器将会把处理器包装成适配器，从而支持多种类型的处理器，即适配器设计模式到应用，从而很容易支持很多类型的处理器。4.HandlerAdapter-->调用处理器相应功能处理方法，并返回一个modelAndView对象（包含模型数据，逻辑视图名）5.ModelAndView(Model部分是业务对象返回的模型数据，View为逻辑视图名）-->viewResovler,视图解析器将把逻辑视图名解析为具体的View\n6.View--->渲染，view会根据传进来的model模型数据进行渲染，此处的model实际是一个map数据结构\n7.返回控制权给DispatcherServerlet，再由DispatcherServlet返回相应给用户，到此一个流程结束。', '<p>1.首先浏览器发送请求–&gt;DispatcherServLet前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局的流程控制：2.DispatcherServlet–&gt;handlerMapping，处理器映射器将会把请求映射HandlerExecutionChain对象（包含一个handler处理器对象，多个HandlerInterceptor拦截器对象）3.DispatcherServlet–&gt;HandlerAdapter,处理器适配器将会把处理器包装成适配器，从而支持多种类型的处理器，即适配器设计模式到应用，从而很容易支持很多类型的处理器。4.HandlerAdapter–&gt;调用处理器相应功能处理方法，并返回一个modelAndView对象（包含模型数据，逻辑视图名）5.ModelAndView(Model部分是业务对象返回的模型数据，View为逻辑视图名）–&gt;viewResovler,视图解析器将把逻辑视图名解析为具体的View<br />\n6.View—&gt;渲染，view会根据传进来的model模型数据进行渲染，此处的model实际是一个map数据结构<br />\n7.返回控制权给DispatcherServerlet，再由DispatcherServlet返回相应给用户，到此一个流程结束。</p>\n', '1560081784687362050');
INSERT INTO `ms_article_body` VALUES ('1560081978141245442', '1.首先浏览器发送请求-->DispatcherServLet前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局的流程控制：\n\n2.DispatcherServlet-->handlerMapping，处理器映射器将会把请求映射HandlerExecutionChain对象（包含一个handler处理器对象，多个HandlerInterceptor拦截器对象）\n\n3.DispatcherServlet-->HandlerAdapter,处理器适配器将会把处理器包装成适配器，从而支持多种类型的处理器，即适配器设计模式到应用，从而很容易支持很多类型的处理器。\n\n4.HandlerAdapter-->调用处理器相应功能处理方法，并返回一个modelAndView对象（包含模型数据，逻辑视图名）\n\n5.ModelAndView(Model部分是业务对象返回的模型数据，View为逻辑视图名）-->viewResovler,视图解析器将把逻辑视图名解析为具体的View\n\n6.View--->渲染，view会根据传进来的model模型数据进行渲染，此处的model实际是一个map数据结构\n\n7.返回控制权给DispatcherServerlet，再由DispatcherServlet返回相应给用户，到此一个流程结束。', '<p>1.首先浏览器发送请求–&gt;DispatcherServLet前端控制器收到请求后自己不进行处理，而是委托给其他解析器进行处理，作为统一访问点，进行全局的流程控制：</p>\n<p>2.DispatcherServlet–&gt;handlerMapping，处理器映射器将会把请求映射HandlerExecutionChain对象（包含一个handler处理器对象，多个HandlerInterceptor拦截器对象）</p>\n<p>3.DispatcherServlet–&gt;HandlerAdapter,处理器适配器将会把处理器包装成适配器，从而支持多种类型的处理器，即适配器设计模式到应用，从而很容易支持很多类型的处理器。</p>\n<p>4.HandlerAdapter–&gt;调用处理器相应功能处理方法，并返回一个modelAndView对象（包含模型数据，逻辑视图名）</p>\n<p>5.ModelAndView(Model部分是业务对象返回的模型数据，View为逻辑视图名）–&gt;viewResovler,视图解析器将把逻辑视图名解析为具体的View</p>\n<p>6.View—&gt;渲染，view会根据传进来的model模型数据进行渲染，此处的model实际是一个map数据结构</p>\n<p>7.返回控制权给DispatcherServerlet，再由DispatcherServlet返回相应给用户，到此一个流程结束。</p>\n', '1560081784687362050');

-- ----------------------------
-- Table structure for ms_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_tag`;
CREATE TABLE `ms_article_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `article_id` bigint NOT NULL,
  `tag_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1560081978116079618 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_article_tag
-- ----------------------------
INSERT INTO `ms_article_tag` VALUES ('4', '9', '7');
INSERT INTO `ms_article_tag` VALUES ('5', '10', '7');
INSERT INTO `ms_article_tag` VALUES ('6', '10', '8');
INSERT INTO `ms_article_tag` VALUES ('7', '10', '5');
INSERT INTO `ms_article_tag` VALUES ('8', '10', '6');
INSERT INTO `ms_article_tag` VALUES ('1405916999787233281', '1405916999732707330', '5');
INSERT INTO `ms_article_tag` VALUES ('1554069326120812546', '1554069326032732161', '5');
INSERT INTO `ms_article_tag` VALUES ('1554430960513294338', '1554430960475545601', '6');
INSERT INTO `ms_article_tag` VALUES ('1555755544973873153', '1555750866936598530', '12');
INSERT INTO `ms_article_tag` VALUES ('1555755544986456066', '1555750866936598530', '8');
INSERT INTO `ms_article_tag` VALUES ('1555755544986456067', '1555750866936598530', '9');
INSERT INTO `ms_article_tag` VALUES ('1555756550415650817', '1', '5');
INSERT INTO `ms_article_tag` VALUES ('1555756550424039426', '1', '9');
INSERT INTO `ms_article_tag` VALUES ('1555780351857688577', '1405909844724051969', '5');
INSERT INTO `ms_article_tag` VALUES ('1555780351866077185', '1405909844724051969', '9');
INSERT INTO `ms_article_tag` VALUES ('1558075069028696065', '1558075068965781505', '5');
INSERT INTO `ms_article_tag` VALUES ('1558075069074833410', '1558075068965781505', '6');
INSERT INTO `ms_article_tag` VALUES ('1558075069154525186', '1558075068965781505', '9');
INSERT INTO `ms_article_tag` VALUES ('1558075069175496705', '1558075068965781505', '7');
INSERT INTO `ms_article_tag` VALUES ('1558397539736682498', '1558042675785564161', '9');
INSERT INTO `ms_article_tag` VALUES ('1558406356910276610', '1558406356893499394', '9');
INSERT INTO `ms_article_tag` VALUES ('1558406356918665217', '1558406356893499394', '5');
INSERT INTO `ms_article_tag` VALUES ('1558406356922859521', '1558406356893499394', '6');
INSERT INTO `ms_article_tag` VALUES ('1558406356935442433', '1558406356893499394', '7');
INSERT INTO `ms_article_tag` VALUES ('1558821583426486274', '1405564731300831233', '9');
INSERT INTO `ms_article_tag` VALUES ('1560081978107691009', '1560081784687362050', '7');
INSERT INTO `ms_article_tag` VALUES ('1560081978116079617', '1560081784687362050', '9');

-- ----------------------------
-- Table structure for ms_category
-- ----------------------------
DROP TABLE IF EXISTS `ms_category`;
CREATE TABLE `ms_category` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_category
-- ----------------------------
INSERT INTO `ms_category` VALUES ('1', '/static/category/front.png', '前端', '前端是什么，大前端');
INSERT INTO `ms_category` VALUES ('2', '/static/category/back.png', '后端', '后端最牛叉');
INSERT INTO `ms_category` VALUES ('3', '/static/category/lift.jpg', '生活', '生活趣事');
INSERT INTO `ms_category` VALUES ('4', '/static/category/database.png', '数据库', '没数据库，啥也不管用');
INSERT INTO `ms_category` VALUES ('5', '/static/category/language.png', '编程语言', '好多语言，该学哪个？');
INSERT INTO `ms_category` VALUES ('6', '/static/category/wangluo.jpg', '网络', '计算机的灵魂');

-- ----------------------------
-- Table structure for ms_comment
-- ----------------------------
DROP TABLE IF EXISTS `ms_comment`;
CREATE TABLE `ms_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint NOT NULL,
  `article_id` bigint NOT NULL,
  `author_id` bigint NOT NULL,
  `parent_id` bigint NOT NULL,
  `to_uid` bigint NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1560082065777033218 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_comment
-- ----------------------------
INSERT INTO `ms_comment` VALUES ('53', '写的好', '123213213213', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('54', '不错', '123123123123', '1', '1', '53', '1', '2');
INSERT INTO `ms_comment` VALUES ('56', '真好', '12312', '1', '1', '0', '1', '1');
INSERT INTO `ms_comment` VALUES ('1405204547248377858', '哎呦，不错', '1623861846172', '1', '1', '53', '1', '2');
INSERT INTO `ms_comment` VALUES ('1405205050975899650', '还可以', '1623861966270', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405205572185280513', '比我写的好', '1623862090534', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405206087392612353', '是真的六', '1623862213367', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405206147568291842', '赶我还差点', '1623862227714', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405206347246522370', '我的博客也不错', '1623862275315', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405208637198131202', '就这', '1623862821278', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1405209691876790274', '不行，有点水', '1623863072732', '1', '1', '1405208637198131202', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553943356810428418', '不错', '1659323941781', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1553973573150982146', '111', '1659331145930', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553973668000972801', '111', '1659331168544', '1', '1', '1405208637198131202', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974195090767873', 'rrr', '1659331294211', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974195099156481', 'rrr', '1659331294216', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974195761856513', 'rrr', '1659331294371', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974197284388865', 'rrr', '1659331294734', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974620888121345', '555', '1659331395729', '1', '1', '1553943356810428418', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553974701729136642', '555', '1659331415004', '1', '1', '1405206347246522370', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553975617429585921', 'eeee', '1659331633323', '1', '1', '1405208637198131202', '1', '2');
INSERT INTO `ms_comment` VALUES ('1553976258709307394', 'iiiii', '1659331786216', '1', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1553976377651380225', 'iiiilll', '1659331814575', '1', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1553976452318380034', 'uuuhhuhu', '1659331832376', '1', '1553229739844591618', '1553976258709307394', '1', '2');
INSERT INTO `ms_comment` VALUES ('1554050092024086529', '还好', '1659349389449', '10', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1554431894161170433', 'test', '1659440418172', '1554430960475545601', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1554431923273834497', '不错', '1659440425114', '1554430960475545601', '1', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1554676579832098818', '好！', '1659498755733', '1', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1554676621754167298', '不错', '1659498765778', '1', '1553229739844591618', '1554676579832098818', '1553229739844591618', '2');
INSERT INTO `ms_comment` VALUES ('1554680922073411585', '不错', '1659499791052', '10', '1553229739844591618', '1554050092024086529', '1553229739844591618', '2');
INSERT INTO `ms_comment` VALUES ('1555023961287548929', '00000', '1659581577961', '1', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1555024256998563841', '666', '1659581648479', '1554430960475545601', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1555024940863053825', '6666', '1659581811525', '1405909844724051969', '1553229739844591618', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1555025003899248641', '66', '1659581826554', '1405909844724051969', '1553229739844591618', '1555024940863053825', '1553229739844591618', '2');
INSERT INTO `ms_comment` VALUES ('1555095072226279425', '不错', '1659598532144', '1405909844724051969', '1555094099747536898', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1555398358997286914', '2222', '1659670841342', '1554430960475545601', '1555096810769481729', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1555398383479439362', '88888', '1659670847182', '1554430960475545601', '1555096810769481729', '1555398358997286914', '1555096810769481729', '2');
INSERT INTO `ms_comment` VALUES ('1555755681720766465', '不错', '1659756033721', '1555750866936598530', '1555096810769481729', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1557275073679888385', '呦西', '1660118284993', '1555750866936598530', '1555096810769481729', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1557348685381697537', '优秀', '1660135835388', '1555750866936598530', '1557347087549005825', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1557351764952940545', '不错', '1660136569618', '1554430960475545601', '1557351658757357569', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1558075143502757889', '非常不错', '1660309036501', '1558075068965781505', '1555096810769481729', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1558075846451331073', '厉害了', '1660309204100', '1558042675785564161', '1555096810769481729', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1558406607125676034', '再详细点就更好了', '1660388063590', '1558406356893499394', '1558082417612881922', '0', '0', '1');
INSERT INTO `ms_comment` VALUES ('1558406648900943873', '666', '1660388073550', '1558406356893499394', '1558082417612881922', '1558406607125676034', '1558082417612881922', '2');
INSERT INTO `ms_comment` VALUES ('1560082065777033217', '不错?', '1660787524061', '1560081784687362050', '1558082417612881922', '0', '0', '1');

-- ----------------------------
-- Table structure for ms_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_permission`;
CREATE TABLE `ms_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_permission
-- ----------------------------
INSERT INTO `ms_permission` VALUES ('1', '查询权限列表', '/admin/permission/permissionList', '查询权限列表');
INSERT INTO `ms_permission` VALUES ('2', '11', '11', '111');
INSERT INTO `ms_permission` VALUES ('7', '1213', '123', '123');
INSERT INTO `ms_permission` VALUES ('8', '删除权限', '/admin/permission/add', '删除权限');

-- ----------------------------
-- Table structure for ms_sys_log
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_log`;
CREATE TABLE `ms_sys_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `create_date` bigint DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `time` bigint DEFAULT NULL,
  `userid` bigint DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_sys_log
-- ----------------------------

-- ----------------------------
-- Table structure for ms_sys_user
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_user`;
CREATE TABLE `ms_sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '账号',
  `admin` bit(1) DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像',
  `create_date` bigint DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1558082417612881923 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_sys_user
-- ----------------------------
INSERT INTO `ms_sys_user` VALUES ('1', 'admin', '', 'http://rfzh8op8d.hn-bkt.clouddn.com/8028a40e-68b1-46c6-b058-210a75e539c2.jpg', '20210622223122', '\0', '11', '20210630223130', '12', '李四', '03a943a0acb374ff0c003b86177bac07', '12', '1');
INSERT INTO `ms_sys_user` VALUES ('1404448463944462338', '12213', '', '/static/img/logo.b3a48c0.png', '1623681581855', '\0', '', '1623681581855', null, '123', '8628d1f407f72e10ac947a032fe5ad29', '', '');
INSERT INTO `ms_sys_user` VALUES ('1404448588146192386', '123', '', '/static/img/logo.b3a48c0.png', '1623681611474', '\0', '', '1623681611474', null, '123', '5e112646dbf3570f8e23d0cf1027ede1', '', '');
INSERT INTO `ms_sys_user` VALUES ('1555096810769481729', 'pp', '', 'http://rfzh8op8d.hn-bkt.clouddn.com/321f8f13-4d81-4de0-b787-5b6a06b2a384.jpg', '1659598946647', '\0', null, '1659598946647', null, '小美', 'd615a09574e1968956f1cd56aaffb5a5', null, null);
INSERT INTO `ms_sys_user` VALUES ('1557347087549005825', '谯', '', 'http://rfzh8op8d.hn-bkt.clouddn.com/59981f69-93b7-456b-89e7-8e4a731f234e.jpg', '1660135454435', '\0', null, '1660135454435', null, '谯', '40a2cfc15a88dcebaa919a7d158c849a', null, null);
INSERT INTO `ms_sys_user` VALUES ('1557351658757357569', 'xiaobai', '', 'http://rfzh8op8d.hn-bkt.clouddn.com/aebaf0c0-7eeb-4f4f-97fc-5e7d64671615.jpeg', '1660136544295', '\0', null, '1660136544295', null, '小白', 'd615a09574e1968956f1cd56aaffb5a5', null, null);
INSERT INTO `ms_sys_user` VALUES ('1558082417612881922', 'root', '', 'http://rfzh8op8d.hn-bkt.clouddn.com/bbb9d521-9951-4ce7-bc5c-f297dbcedf24.jpg', '1660310770788', '\0', null, '1660310770788', null, '蒲骏', 'd615a09574e1968956f1cd56aaffb5a5', null, null);

-- ----------------------------
-- Table structure for ms_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_tag`;
CREATE TABLE `ms_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of ms_tag
-- ----------------------------
INSERT INTO `ms_tag` VALUES ('5', '/static/tag/java.png', 'springboot');
INSERT INTO `ms_tag` VALUES ('6', '/static/tag/java.png', 'spring');
INSERT INTO `ms_tag` VALUES ('7', '/static/tag/java.png', 'springmvc');
INSERT INTO `ms_tag` VALUES ('8', '/static/tag/css.png', 'css');
INSERT INTO `ms_tag` VALUES ('9', '/static/tag/笔记.png', '笔记');
INSERT INTO `ms_tag` VALUES ('11', '/static/tag/vue.png', 'Vue');
INSERT INTO `ms_tag` VALUES ('12', '/static/tag/html.png', 'html');
